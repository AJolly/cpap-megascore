<!DOCTYPE html>
<html lang="en-GB">

<head>
    <title>MegaScore CPAP Analyzer</title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="EDFFile.js"></script>
    <script src="FlowLimits.js"></script>

    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 95vw;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        @media (min-width: 1400px) {
            .container {
                max-width: 90vw;
            }
        }

        @media (min-width: 2000px) {
            .container {
                max-width: 85vw;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }

        .upload-section {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px dashed #ccc;
        }

        .upload-section.drag-over {
            border-color: #007bff;
            background-color: #e7f3ff;
        }

        .results-section {
            display: none;
            margin-top: 20px;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-card {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            text-align: center;
        }

        .summary-card h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .summary-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }

        .chart-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
        }

        .night-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
        }

        .night-table th,
        .night-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .night-table th {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }

        .night-table tr:hover {
            background-color: #f8f9fa;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
        }

        .file-count {
            margin: 10px 0;
            color: #666;
        }

        .gi-value {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }

        .gi-excellent {
            background-color: #d4edda;
            color: #155724;
        }

        .gi-good {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        .gi-fair {
            background-color: #fff3cd;
            color: #856404;
        }

        .gi-poor {
            background-color: #f8d7da;
            color: #721c24;
        }

        .gi-very-poor {
            background-color: #f5c6cb;
            color: #491217;
        }

        /* Header info pills */
        .info-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-top: 10px;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid #e0e0e0;
            background: #fafafa;
            color: #333;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
        }

        .pill a {
            color: #007bff;
            text-decoration: none;
        }

        .pill a:hover {
            text-decoration: underline;
        }

        .pill--contact {
            border-color: #cfe2ff;
            background: #f0f6ff;
        }

        .pill--privacy {
            border-color: #d1e7dd;
            background: #f3fff6;
        }

        .pill--source {
            border-color: #ffe69c;
            background: #fff9e6;
        }

        .ack-line {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }

        /* --- Sub-session expandable rows --- */
        .night-row-expandable {
            cursor: pointer;
        }

        .night-row-expandable:hover {
            background-color: #e8f0fe !important;
        }

        .expand-toggle {
            display: inline-block;
            width: 18px;
            font-size: 12px;
            color: #007bff;
            margin-right: 4px;
            transition: transform 0.15s ease;
        }

        .sub-session-row {
            background-color: #f9fbff;
            font-size: 13px;
        }

        .sub-session-row td:first-child {
            padding-left: 32px;
        }

        .sub-session-row.excluded {
            opacity: 0.45;
        }

        .sub-session-row.excluded td {
            text-decoration: line-through;
            text-decoration-color: #aaa;
        }

        .session-type-badge {
            display: inline-block;
            padding: 2px 7px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }

        .badge-main {
            background: #d4edda;
            color: #155724;
        }

        .badge-noon-split {
            background: #cfe2ff;
            color: #084298;
        }

        .badge-bathroom {
            background: #fff3cd;
            color: #664d03;
        }

        .badge-nap {
            background: #e2d5f1;
            color: #432874;
        }

        .include-cb {
            cursor: pointer;
            width: 15px;
            height: 15px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .session-count-pill {
            display: inline-block;
            padding: 1px 6px;
            border-radius: 8px;
            font-size: 11px;
            background: #e9ecef;
            color: #495057;
            margin-left: 6px;
        }

        /* CPAP settings columns - hidden by default */
        .cpap-col {
            display: none;
        }
    </style>

</head>

<body>

    <div class="container">
        <div class="header">
            <h1>MegaScore CPAP Analyzer</h1>
            <p>Combined Glasgow Index + Ventilatory Stability Analysis</p>
            <div class="info-pills">
                <span class="pill pill--privacy">üîí All processing happens locally in your browser</span>
            </div>
            <div class="ack-line">Glasgow Index by <a href="https://github.com/DaveSkvn/GlasgowIndex" target="_blank"
                    rel="noopener noreferrer">DaveSkvn</a> | Multi-Night Analyzer by <a
                    href="https://github.com/VibeCoder75321/Multi-Night-Glasgow-Index-Analyzer" target="_blank"
                    rel="noopener noreferrer">VibeCoder75321</a> | Wobble Analysis from <a
                    href="https://github.com/existentialblu/wobble-analysis-tool" target="_blank"
                    rel="noopener noreferrer">existentialblu</a>
                (<a href="https://wobble-analysis-tool.xyz/" target="_blank"
                    rel="noopener noreferrer">wobble-analysis-tool.xyz</a>)</div>
        </div>

        <details class="upload-section" id="uploadSection" open>
            <summary style="cursor: pointer;">
                <h3 style="display: inline; margin: 0;">Upload Entire SD Card Data for complete analysis</h3>
            </summary>
            <!-- <p><strong>For complete analysis including pressure settings, machine type, and all Glasgow Index data:</strong></p> -->

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div
                    style="text-align: center; padding: 20px; border: 2px solid #007bff; border-radius: 8px; background: #f8f9ff;">
                    <h4 style="margin-top: 0; color: #007bff;">üìÅ Upload Entire SD Card</h4>
                    <p style="font-size: 14px; color: #666; margin-bottom: 15px;"><strong>Recommended:</strong> Select
                        your entire ResMed or Philips SD card root folder</p>
                    <input type="file" id="folderInput" webkitdirectory multiple style="margin: 10px 0;">
                    <div style="font-size: 12px; color: #333; margin-top: 10px; font-weight: bold;">
                        <!-- ‚úÖ Includes: DATALOG, STR.edf, Identification.tgt, SETTINGS -->
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        <!-- Extracts: Machine Type, IPAP, EPAP, Pressure Support, PAP Mode -->
                    </div>
                </div>

                <div
                    style="text-align: center; padding: 20px; border: 2px dashed #ffc107; border-radius: 8px; background: #fffbf0;">
                    <h4 style="margin-top: 0; color: #856404;">üìÑ Or Upload Individual Files</h4>
                    <p style="font-size: 14px; color: #666; margin-bottom: 15px;">Helpful to review a single night or an
                        OSCAR Backup</p>
                    <input type="file" name="inputfiles" id="fileInput" multiple accept=".edf" style="margin: 10px 0;">
                    <div style="font-size: 12px; color: #856404; margin-top: 10px; font-weight: bold;">
                        ‚ö†Ô∏è Limited: Glasgow Index only
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        <!-- Missing: Pressure data, machine settings -->
                    </div>
                </div>
            </div>


            <div class="file-count" id="fileCount">No files selected</div>
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="processingStatus"></div>
        </details>

        <div class="results-section" id="resultsSection">
            <div class="summary-cards">
                <div class="summary-card">
                    <h3>Nights Analyzed</h3>
                    <div class="value" id="nightsCount">0</div>
                </div>
                <div class="summary-card">
                    <h3>Average Overall GI</h3>
                    <div class="value" id="avgOverallGI">0.00</div>
                </div>
                <div class="summary-card">
                    <h3>Best Night GI</h3>
                    <div class="value" id="bestNightGI">0.00</div>
                </div>
                <div class="summary-card">
                    <h3>Worst Night GI</h3>
                    <div class="value" id="worstNightGI">0.00</div>
                </div>
            </div>
            <div class="chart-container">
                <h3>Glasgow Index Trends Over Time</h3>
                <div style="margin-bottom: 15px;">
                    <label for="dateRangeSelect">Date Range:</label>
                    <select id="dateRangeSelect" style="margin: 0 10px; padding: 5px;"
                        onchange="onDateRangeChange(); updateAllCharts()">
                        <option value="all">All Data</option>
                        <option value="30">Last 30 Days</option>
                        <option value="60">Last 60 Days</option>
                        <option value="90">Last 90 Days</option>
                        <option value="custom">Custom‚Ä¶</option>
                    </select>
                    <span id="customDateBlock" style="display: none;">
                        <input type="date" id="customStartDate" style="padding: 5px; margin-right: 6px;">
                        <input type="date" id="customEndDate" style="padding: 5px; margin-right: 10px;">
                    </span>

                    <label for="smoothingSelect">Smoothing:</label>
                    <select id="smoothingSelect" style="margin: 0 10px; padding: 5px;">
                        <option value="none">None</option>
                        <option value="3">3-day Moving Average</option>
                        <option value="7">7-day Moving Average</option>
                        <option value="14">14-day Moving Average</option>
                    </select>
                    <label style="margin-left: 10px;">
                        <input type="checkbox" id="hideShortNights" checked onchange="updateAllCharts()"> Hide Nights
                        &lt;4 Hours
                    </label>

                    <button onclick="updateAllCharts()" style="padding: 5px 15px;">Update Charts</button>
                </div>
                <div style="position: relative; height: 400px; width: 100%;">
                    <canvas id="trendsChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3>Component Analysis</h3>
                <div style="margin-bottom: 15px;">
                    <label>
                        <input type="checkbox" id="showTrendLines" checked onchange="updateComponentsChart()">
                        Show Trend Lines
                    </label>
                </div>

                <!-- Component Filter Panel -->
                <div id="componentFilter"
                    style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px; border: 1px solid #dee2e6;">
                    <div style="font-weight: bold; margin-bottom: 10px;">Select Components to Display:</div>
                    <div
                        style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px;">
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_skew" checked
                                onchange="updateComponentsChart()"> Skew</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_spike" checked
                                onchange="updateComponentsChart()"> Spike</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_flatTop" checked
                                onchange="updateComponentsChart()"> Flat Top</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_topHeavy" checked
                                onchange="updateComponentsChart()"> Top Heavy</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_multiPeak" checked
                                onchange="updateComponentsChart()"> Multi Peak</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_noPause" checked
                                onchange="updateComponentsChart()"> No Pause</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_inspirRate" checked
                                onchange="updateComponentsChart()"> Inspir Rate</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_multiBreath" checked
                                onchange="updateComponentsChart()"> Multi Breath</label>
                        <label style="font-size: 13px;"><input type="checkbox" id="comp_ampVar" checked
                                onchange="updateComponentsChart()"> Variable Amp</label>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="selectAllComponents()"
                            style="padding: 4px 8px; font-size: 12px; background: #28a745; color: white; border: none; border-radius: 3px;">All</button>
                        <button onclick="selectNoComponents()"
                            style="padding: 4px 8px; font-size: 12px; background: #dc3545; color: white; border: none; border-radius: 3px;">None</button>
                        <button onclick="selectMainComponents()"
                            style="padding: 4px 8px; font-size: 12px; background: #007bff; color: white; border: none; border-radius: 3px;">Main
                            Issues</button>
                        <button onclick="selectFlowComponents()"
                            style="padding: 4px 8px; font-size: 12px; background: #6f42c1; color: white; border: none; border-radius: 3px;">Flow
                            Shape</button>
                        <button onclick="selectTimingComponents()"
                            style="padding: 4px 8px; font-size: 12px; background: #fd7e14; color: white; border: none; border-radius: 3px;">Timing</button>
                    </div>
                </div>

                <div style="position: relative; height: 400px; width: 100%;">
                    <canvas id="componentsChart"></canvas>
                </div>
            </div>

            <!-- Moved Heatmap block to just above the detailed table -->
            <div class="chart-container">
                <h3 style="margin-bottom: 10px;">Night Heatmap</h3>
                <div style="margin-bottom: 10px;">
                    <label for="nightSelect" style="margin-right: 8px;">Select Night:</label>
                    <button id="nightPrev" onclick="prevNight()" title="Older night"
                        style="padding: 4px 8px; margin-right: 6px;">‚óÄ</button>
                    <select id="nightSelect" onchange="updateNightHeatmap()"
                        style="padding: 5px 8px; margin-right: 6px;"></select>
                    <button id="nightNext" onclick="nextNight()" title="Newer night"
                        style="padding: 4px 8px; margin-right: 10px;">‚ñ∂</button>

                    <label
                        style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer; margin-right: 10px;">
                        <input type="checkbox" id="heatmapSessionToggle" onchange="toggleHeatmapSessionView()">
                        <span>Show Individual Sessions</span>
                    </label>

                    <span id="sessionSelectBlock" style="display: none;">
                        <label for="sessionSelect" style="margin-right: 6px;">Session:</label>
                        <select id="sessionSelect" onchange="updateSessionHeatmap()" style="padding: 5px 8px;"></select>
                    </span>
                </div>
                <div style="position: relative; height: 400px; width: 100%;">
                    <canvas id="chartTop"></canvas>
                </div>
                <div id="detailChartSection" style="display:none; margin-top: 15px;">
                    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                        <button onclick="scrollDetailLeft()" style="padding:4px 10px;">‚óÄ Earlier</button>
                        <span id="detailTimeLabel" style="font-weight:bold;"></span>
                        <button onclick="scrollDetailRight()" style="padding:4px 10px;">Later ‚ñ∂</button>
                    </div>
                    <div style="position: relative; height: 350px; width: 100%;">
                        <canvas id="chartDetail"></canvas>
                    </div>
                </div>
                <!-- Hidden buttons that FlowLimits.js expects for showDetailOneMinute -->
                <button id="backBtn" style="display:none;" onclick="scrollDetailLeft()"></button>
                <button id="fwdBtn" style="display:none;" onclick="scrollDetailRight()"></button>
            </div>

            <div
                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                <h3 style="margin: 0;" id="resultsTableTitle">Detailed Night-by-Night Results</h3>
                <div style="display: flex; gap: 15px; align-items: center;">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="sessionViewToggle" onchange="toggleSessionView()">
                        <span>Show Individual Sessions</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;"
                        id="hideShortSessionsLabel" style="display: none;">
                        <input type="checkbox" id="hideShortSessions" checked onchange="toggleSessionView()">
                        <span>Hide &lt;20 min sessions</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="showCpapSettings" onchange="toggleCpapColumns()">
                        <span>Show CPAP Settings</span>
                    </label>
                    <button onclick="exportNightlyCSV()"
                        style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                        üìä Export to CSV
                    </button>
                </div>
            </div>
            <table class="night-table" id="resultsTable">
                <thead>
                    <tr id="tableHeaderRow">
                        <th>Date</th>
                        <th>Start Time</th>
                        <th>End Time</th>
                        <th>Duration (hrs)</th>
                        <th>Machine Type</th>
                        <th>PAP Mode</th>
                        <th>Overall GI</th>
                        <th>Skew</th>
                        <th>Spike</th>
                        <th>Flat Top</th>
                        <th>Top Heavy</th>
                        <th>Multi Peak</th>
                        <th>No Pause</th>
                        <th>Inspir Rate</th>
                        <th>Multi Breath</th>
                        <th>Variable Amp</th>
                        <th title="Sleep Disruption Score (0-100) ‚Äî composite: averages Flow Limitation, Periodicity, Regularity with EAI. Lower is better."
                            style="background:#5a2d9c; font-weight:bold; color:white;">Sleep Disruption</th>
                        <th title="Flow Limitation Score (0-100) ‚Äî higher = flatter inspiratory flow"
                            style="background:#6f42c1; color:white;">Flow Limitation</th>
                        <th title="Regularity Score (0-100) ‚Äî higher = more regular. From entropy."
                            style="background:#6f42c1; color:white;">Regularity</th>
                        <th title="Periodicity Score ‚Äî higher = more periodic breathing"
                            style="background:#6f42c1; color:white;">
                            Periodicity</th>
                        <th title="Estimated Arousal Index ‚Äî events per hour based on breathing changes"
                            style="background:#6f42c1; color:white;">EAI</th>
                        <th title="Base IPAP or Max PS (ASV)" class="cpap-col">IPAP/MaxPS</th>
                        <th title="Min IPAP (AutoSet)" class="cpap-col">Min IPAP</th>
                        <th title="Max IPAP (AutoSet/VAuto) or Max EPAP (ASVAuto)" class="cpap-col">Max IPAP/Max EPAP
                        </th>
                        <th title="Base EPAP" class="cpap-col">EPAP</th>
                        <th title="Base EPAP or Min EPAP (VAuto/ASV)" class="cpap-col">Min EPAP</th>
                        <th title="Max EPAP (ASVAuto)" class="cpap-col">Max EPAP</th>
                        <th title="Pressure Support or Min PS" class="cpap-col">PS / Min PS</th>
                        <th class="cpap-col">EasyBreathe</th>
                        <th class="cpap-col">Rise Time</th>
                        <th class="cpap-col">Trigger</th>
                        <th class="cpap-col">Cycle</th>
                        <th>Notes</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="resultsTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Release Notes (collapsed by default) -->
    <div class="container" style="margin-top: 16px;">
        <details>
            <summary style="cursor:pointer; font-weight:600;">Release Notes ‚Äî Updated: <span
                    id="releaseNotesDate">2026-02-25</span></summary>
            <div style="margin-top:10px; font-size: 14px; color: #222; line-height: 1.6;">
                <div
                    style="background:#f0e6ff; border:1px solid #d4b5ff; border-radius:8px; padding:12px; margin-bottom:12px;">
                    <div style="font-weight:bold; margin-bottom:6px;">2026-02-25 ‚Äî MegaScore</div>
                    <ul style="margin:0 0 8px 18px;">
                        <li><strong>Combined analyzer:</strong> Glasgow Index + Wobble ventilatory stability analysis in
                            one tool</li>
                        <li><strong>Wobble scoring per session:</strong> Sample Entropy, Regularity Score, FFT
                            Periodicity,
                            Flow Limitation Score, dominant Breaths/Min &mdash; visible in table columns (purple
                            headers)</li>
                        <li><strong>Heatmap click-to-inspect:</strong> Click any event in the heatmap to view the
                            detailed flow graph
                            for that minute &mdash; works across multi-session nights</li>
                        <li><strong>Philips DreamStation support:</strong> Auto-detects P-SERIES folder structure,
                            parses .005 waveform files,
                            reads timestamps from .001 headers, runs full GI + Wobble analysis</li>
                        <li><strong>IndexedDB result caching:</strong> Parsed results cached locally &mdash; subsequent
                            loads
                            skip re-parsing for instant results</li>
                        <li><strong>Settings panel:</strong> Click &#9881;&#65039; Analysis Settings to tune GI
                            thresholds, Wobble
                            parameters, session classification &mdash; all saved to localStorage</li>
                        <li><strong>UI improvements:</strong> Upload section auto-collapses after loading data;
                            checkbox toggles no longer collapse expanded sessions</li>
                        <li>Rebranded to MegaScore with full attribution to DaveSkvn (GI), VibeCoder75321 (Multi-Night),
                            and <a href="https://wobble-analysis-tool.xyz/" target="_blank">existentialblu Wobble</a>
                        </li>
                    </ul>
                </div>
                <div
                    style="background:#f8f9fa; border:1px solid #e9ecef; border-radius:8px; padding:12px; margin-bottom:12px;">
                    <div style="font-weight:bold; margin-bottom:6px;">2025-12-10</div>
                    <ul style="margin:0 0 8px 18px;">
                        <li><strong>Improved sleep night grouping:</strong> Sessions are now grouped by DATALOG folder
                            date instead of filename timestamp heuristics</li>
                        <li>When uploading an SD card folder, the folder name (e.g., <code>DATALOG/20250724/</code>)
                            determines which night a session belongs to</li>
                        <li>This correctly handles sessions that cross midnight ‚Äî all data stays grouped under the night
                            you went to sleep</li>
                        <li>Individual file uploads still use time-based fallback for backward compatibility</li>
                    </ul>
                </div>
                <div style="background:#f8f9fa; border:1px solid #e9ecef; border-radius:8px; padding:12px;">
                    <div style="font-weight:bold; margin-bottom:6px;">2025-09-27</div>
                    <ul style="margin:0 0 8px 18px;">
                        <li>STR.edf settings extraction: <code>S.RiseTime</code>, <code>S.Trigger</code>,
                            <code>S.Cycle</code>, <code>S.EasyBreathe</code>
                        </li>
                        <li>Per-night display and CSV export for machine settings</li>
                        <li>When EasyBreathe is <strong>On</strong>, Rise Time is shown as <strong>N/A</strong></li>
                        <li>Trigger/Cycle labels: 4=very high, 3=high, 2=medium, 1=low, 0=very low</li>
                        <li>Header pills for contact, privacy, source, plus acknowledgment</li>
                    </ul>
                </div>
            </div>
        </details>
    </div>

    <script type="text/javascript">

        let nightlyResults = [];
        var chartDetail = null;
        var detailSampleSelected = 0;
        let trendsChart = null;
        let componentsChart = null;
        let showSessionView = false; // Toggle between night aggregation and session view

        // Override clearDetailGraph from FlowLimits.js to avoid missing DOM element errors
        function clearDetailGraph() {
            if (chartDetail != null) {
                chartDetail.destroy();
                chartDetail = null;
            }
            const section = document.getElementById('detailChartSection');
            if (section) section.style.display = 'none';
        }

        // Scroll wrapper functions for detail chart navigation
        function scrollDetailLeft() {
            if (!chartDetail || !window.dataArray || !window.results) return;
            const MOVE = 1125;
            let pos = Math.max(0, detailSampleSelected - MOVE);
            showDetailOneMinute(window.dataArray, window.results, pos);
            showDetailSection();
        }
        function scrollDetailRight() {
            if (!chartDetail || !window.dataArray || !window.results) return;
            const MOVE = 1125;
            let pos = Math.min(window.dataArray.length - 750, detailSampleSelected + MOVE);
            showDetailOneMinute(window.dataArray, window.results, pos);
            showDetailSection();
        }
        function showDetailSection() {
            const section = document.getElementById('detailChartSection');
            if (section) section.style.display = 'block';
            // Update time label
            if (window.startDateTime && window.dataArray) {
                const sampleMs = detailSampleSelected * MILLIS_PER_SAMPLE;
                const t = new Date(window.startDateTime.getTime() + sampleMs);
                const label = document.getElementById('detailTimeLabel');
                if (label) label.textContent = t.toLocaleTimeString();
            }
        }

        // Deduplicate nightlyResults by unique session key (file + date + time)
        function deduplicateResults() {
            const seen = new Set();
            nightlyResults = nightlyResults.filter(r => {
                const key = (r.fileName || '') + '|' + r.date + '|' + r.time;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        // ============ IndexedDB Result Cache ============
        // Stores parsed session results so we don't re-parse files every time.
        // Key: filename, Value: session result object (without raw flow data to save space)
        const CACHE_DB_NAME = 'megascore_cache';
        const CACHE_DB_VERSION = 1;
        const CACHE_STORE_NAME = 'sessions';

        function openCacheDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(CACHE_DB_NAME, CACHE_DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(CACHE_STORE_NAME)) {
                        db.createObjectStore(CACHE_STORE_NAME, { keyPath: 'fileName' });
                    }
                };
            });
        }

        async function getCachedResult(fileName) {
            try {
                const db = await openCacheDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(CACHE_STORE_NAME, 'readonly');
                    const store = tx.objectStore(CACHE_STORE_NAME);
                    const request = store.get(fileName);
                    request.onsuccess = () => {
                        const result = request.result;
                        if (result) {
                            // Restore Date objects (they get serialized to strings in IDB)
                            if (result.startDateTime) result.startDateTime = new Date(result.startDateTime);
                            if (result.endDateTime) result.endDateTime = new Date(result.endDateTime);

                            // Rebuild flowData from compact y-values + timestamps
                            if (result.flowYValues && result.flowYValues.length > 0) {
                                const startTime = result.startDateTime || new Date();
                                const sampleIntervalMs = 40; // 25 Hz
                                result.flowData = result.flowYValues.map((y, i) => ({
                                    x: formatChartDate(new Date(startTime.getTime() + i * sampleIntervalMs)),
                                    y: y
                                }));
                                delete result.flowYValues;
                                delete result.flowStartTime;
                            }
                            // Rebuild idealData from compact y-values
                            if (result.idealYValues && result.idealYValues.length > 0) {
                                const startTime = result.startDateTime || new Date();
                                const sampleIntervalMs = 40;
                                result.idealData = result.idealYValues.map((y, i) => ({
                                    x: formatChartDate(new Date(startTime.getTime() + i * sampleIntervalMs)),
                                    y: y
                                }));
                                delete result.idealYValues;
                            }
                        }
                        resolve(result || null);
                    };
                    request.onerror = () => resolve(null);
                });
            } catch (e) {
                console.warn('Cache read error:', e);
                return null;
            }
        }

        async function setCachedResult(result) {
            try {
                const db = await openCacheDB();
                // Store compact copy: replace flowData [{x,y},...] with just y-values array
                // This dramatically reduces cache size while keeping flow data for click-to-inspect
                const cacheObj = Object.assign({}, result);
                if (cacheObj.flowData && cacheObj.flowData.length > 0) {
                    cacheObj.flowYValues = cacheObj.flowData.map(d => d.y);
                    cacheObj.flowStartTime = cacheObj.flowData[0].x;
                }
                delete cacheObj.flowData;
                // idealData is also [{x,y},...] ‚Äî store just y-values
                if (cacheObj.idealData && cacheObj.idealData.length > 0) {
                    cacheObj.idealYValues = cacheObj.idealData.map(d => d.y);
                }
                delete cacheObj.idealData;
                const tx = db.transaction(CACHE_STORE_NAME, 'readwrite');
                const store = tx.objectStore(CACHE_STORE_NAME);
                store.put(cacheObj);
                return new Promise((resolve) => {
                    tx.oncomplete = () => resolve(true);
                    tx.onerror = () => resolve(false);
                });
            } catch (e) {
                console.warn('Cache write error:', e);
                return false;
            }
        }

        async function clearResultCache() {
            try {
                const db = await openCacheDB();
                const tx = db.transaction(CACHE_STORE_NAME, 'readwrite');
                tx.objectStore(CACHE_STORE_NAME).clear();
                return new Promise((resolve) => {
                    tx.oncomplete = () => {
                        console.log('Result cache cleared');
                        resolve(true);
                    };
                    tx.onerror = () => resolve(false);
                });
            } catch (e) {
                console.warn('Cache clear error:', e);
                return false;
            }
        }

        async function getCacheCount() {
            try {
                const db = await openCacheDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(CACHE_STORE_NAME, 'readonly');
                    const store = tx.objectStore(CACHE_STORE_NAME);
                    const request = store.count();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(0);
                });
            } catch (e) { return 0; }
        }

        async function getAllCachedResults() {
            try {
                const db = await openCacheDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(CACHE_STORE_NAME, 'readonly');
                    const store = tx.objectStore(CACHE_STORE_NAME);
                    const request = store.getAll();
                    request.onsuccess = () => {
                        const results = request.result;
                        if (results) {
                            results.forEach(result => {
                                if (result.startDateTime) result.startDateTime = new Date(result.startDateTime);
                                if (result.endDateTime) result.endDateTime = new Date(result.endDateTime);
                                // IMPORTANT: Do NOT rebuild flowData/idealData here.
                                // Keep compact y-value arrays to avoid OOM on bulk load.
                                // Flow data is rebuilt lazily via ensureFlowData() when needed.
                            });
                        }
                        resolve(results || []);
                    };
                    request.onerror = () => resolve([]);
                });
            } catch (e) { return []; }
        }

        /**
         * Lazily rebuild flowData/idealData from compact y-value arrays.
         * Call this only for sessions whose flow data is actually needed (e.g. click-to-inspect).
         */
        function ensureFlowData(session) {
            if (session.flowData && session.flowData.length > 0) return; // already built
            if (session.flowYValues && session.flowYValues.length > 0) {
                const startTime = session.startDateTime || new Date();
                const sampleIntervalMs = 40;
                session.flowData = session.flowYValues.map((y, i) => ({
                    x: formatChartDate(new Date(startTime.getTime() + i * sampleIntervalMs)),
                    y: y
                }));
                delete session.flowYValues;
                delete session.flowStartTime;
            }
            if (!session.idealData && session.idealYValues && session.idealYValues.length > 0) {
                const startTime = session.startDateTime || new Date();
                const sampleIntervalMs = 40;
                session.idealData = session.idealYValues.map((y, i) => ({
                    x: formatChartDate(new Date(startTime.getTime() + i * sampleIntervalMs)),
                    y: y
                }));
                delete session.idealYValues;
            }
        }

        async function loadCachedSessions() {
            document.getElementById('processingStatus').innerHTML = `Loading cached sessions...`;
            const results = await getAllCachedResults();
            if (results && results.length > 0) {
                nightlyResults = results;
                document.getElementById('processingStatus').innerHTML = `Loaded ${results.length} sessions from cache!`;
                displayResults();
            } else {
                document.getElementById('processingStatus').innerHTML = `No cached sessions found.`;
            }
        }

        // Show cache status on load
        (async () => {
            const count = await getCacheCount();
            if (count > 0) {
                document.getElementById('fileCount').innerHTML =
                    `No files selected ‚Äî <strong>${count} cached sessions</strong> available (upload to combine with cache) ` +
                    `<button onclick="loadCachedSessions()" style="padding:2px 8px; font-size:11px; background:#28a745; color:white; border:none; border-radius:3px; cursor:pointer; margin-right:5px;">Load Cache</button>` +
                    `<button onclick="clearResultCache().then(() => { document.getElementById('fileCount').textContent = 'Cache cleared. No files selected.'; })" ` +
                    `style="padding:2px 8px; font-size:11px; background:#dc3545; color:white; border:none; border-radius:3px; cursor:pointer;">Clear Cache</button>`;
            }
        })();

        // ============ Session Inclusion Persistence (localStorage) ============
        const STORAGE_KEY_INCLUSION = 'glasgowIndex_sessionInclusion';

        function getSessionInclusion(fileName) {
            try {
                const data = JSON.parse(localStorage.getItem(STORAGE_KEY_INCLUSION) || '{}');
                return data.hasOwnProperty(fileName) ? data[fileName] : null; // null = use default
            } catch (e) { return null; }
        }

        function saveSessionInclusion(fileName, included) {
            try {
                const data = JSON.parse(localStorage.getItem(STORAGE_KEY_INCLUSION) || '{}');
                data[fileName] = included;
                localStorage.setItem(STORAGE_KEY_INCLUSION, JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save session inclusion:', e);
            }
        }

        // ============ Session Classification Engine ============

        /** Format wobble metric for display. Returns 'N/A' for NaN/undefined. */
        function fmtWobble(val, decimals = 3) {
            if (val === undefined || val === null || isNaN(val)) return 'N/A';
            return Number(val).toFixed(decimals);
        }

        /**
         * Classify sessions within a night and assign _sessionType and _includedInDay.
         * 
         * Types:
         *   'main'       ‚Äî Primary sleep block (evening ‚Üí morning). Included by default.
         *   'noon-split'  ‚Äî ResMed auto-split at noon; continuation of main sleep. Included.
         *   'bathroom'    ‚Äî Short gap during nighttime hours (8PM‚Äì10AM). Included.
         *   'nap'         ‚Äî Standalone daytime session (12PM‚Äì8PM, ‚â§3 hrs). Excluded by default.
         *
         * Time-of-day heuristic:
         *   - Sessions during "nighttime" (8 PM ‚Äì 10 AM) are part of the main sleep context.
         *   - Sessions during "daytime" (10 AM ‚Äì 8 PM) that are short are likely naps.
         *   - ResMed splits at exactly noon are auto-detected by checking the gap around 12:00.
         */
        function classifySessionsForNight(sessions) {
            if (!sessions || sessions.length === 0) return;

            // Sort by start time
            sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));

            // Helper: is this hour in the "nighttime sleep" window? (8PM-midnight or midnight-10AM)
            function isNighttimeHour(hour) {
                return hour >= 20 || hour < 12;
            }

            // Helper: is a time near noon? (within 30 minutes of 12:00)
            function isNearNoon(date) {
                const h = date.getHours();
                const m = date.getMinutes();
                const minutesSinceNoon = (h - 12) * 60 + m;
                return Math.abs(minutesSinceNoon) <= 30;
            }

            // First pass: classify each session
            for (let i = 0; i < sessions.length; i++) {
                const session = sessions[i];
                const startDt = new Date(session.startDateTime);
                const startHour = startDt.getHours();
                const durationHrs = session.duration;

                // Check for noon-split: session starts near noon AND previous session ended near noon
                if (i > 0) {
                    const prevSession = sessions[i - 1];
                    const prevEndDt = new Date(prevSession.endDateTime ||
                        new Date(prevSession.startDateTime).getTime() + prevSession.duration * 3600000);
                    const gapMs = startDt - prevEndDt;
                    const gapMinutes = gapMs / 60000;

                    // Very short gap (‚â§ 10 min): always a mask-off break, regardless of time
                    // This catches cases like main sleep ending at 10:18 AM and restarting at 10:21 AM
                    if (gapMinutes >= 0 && gapMinutes <= 10) {
                        session._sessionType = 'bathroom';
                        session._defaultIncluded = true;
                    }
                    // Noon-split: both end-of-prev and start-of-current are near noon, gap < 30min
                    else if (isNearNoon(prevEndDt) && isNearNoon(startDt) && gapMinutes >= 0 && gapMinutes <= 30) {
                        session._sessionType = 'noon-split';
                        session._defaultIncluded = true;
                    }
                    // Bathroom break: short gap during nighttime/morning hours
                    // Gap < 60min during nighttime context (8PM‚Äìnoon)
                    else if (gapMinutes >= 0 && gapMinutes <= 60 && isNighttimeHour(startHour)) {
                        if (gapMinutes <= 30) {
                            session._sessionType = 'bathroom';
                            session._defaultIncluded = true;
                        }
                        // Slightly longer gap but still nighttime ‚Üí probably still part of main sleep
                        else if (durationHrs >= 0.5) {
                            session._sessionType = 'main';
                            session._defaultIncluded = true;
                        } else {
                            session._sessionType = 'bathroom';
                            session._defaultIncluded = true;
                        }
                    }
                }

                // If not yet classified
                if (!session._sessionType) {
                    // Nap detection: daytime (10AM‚Äì8PM), short duration (‚â§3 hrs)
                    if (startHour >= 10 && startHour < 20 && durationHrs <= 3) {
                        session._sessionType = 'nap';
                        session._defaultIncluded = false;
                    } else {
                        session._sessionType = 'main';
                        session._defaultIncluded = true;
                    }
                }

                // Apply saved user preference or use default
                const savedInclusion = getSessionInclusion(session.fileName);
                session._includedInDay = (savedInclusion !== null) ? savedInclusion : session._defaultIncluded;
            }
        }

        /**
         * Session type display info
         */
        function getSessionTypeBadge(type) {
            const badges = {
                'main': { emoji: 'üõèÔ∏è', label: 'Main', cssClass: 'badge-main' },
                'noon-split': { emoji: 'üîó', label: 'Continuation', cssClass: 'badge-noon-split' },
                'bathroom': { emoji: 'üöø', label: 'Break', cssClass: 'badge-bathroom' },
                'nap': { emoji: 'üí§', label: 'Nap', cssClass: 'badge-nap' }
            };
            return badges[type] || badges['main'];
        }

        /**
         * Compute duration-weighted wobble averages across included sessions.
         */
        function computeWeightedWobble(sessions, totalDuration) {
            if (!sessions || sessions.length === 0 || totalDuration <= 0) {
                return { flScore: 0, periodicityIndex: 0, regularityScore: 0, eai: 0, composite: 0 };
            }
            const withWobble = sessions.filter(s => s.wobble && !isNaN(s.wobble.composite));
            if (withWobble.length === 0) {
                return { flScore: 0, periodicityIndex: 0, regularityScore: 0, eai: 0, composite: 0 };
            }
            const wobbleDuration = withWobble.reduce((s, sess) => s + sess.duration, 0);
            if (wobbleDuration <= 0) return { flScore: 0, periodicityIndex: 0, regularityScore: 0, eai: 0, composite: 0 };

            let wFL = 0, wPeriod = 0, wReg = 0, wEai = 0, wComp = 0;
            withWobble.forEach(s => {
                const w = s.duration / wobbleDuration;
                wFL += (s.wobble.flScore || 0) * w;
                wPeriod += (s.wobble.periodicityIndex || 0) * w;
                wReg += (s.wobble.regularityScore || 0) * w;
                wEai += (s.wobble.eai || 0) * w;
                wComp += (s.wobble.composite || 0) * w;
            });
            return {
                flScore: Math.round(wFL * 10) / 10,
                periodicityIndex: Math.round(wPeriod * 10) / 10,
                regularityScore: Math.round(wReg * 10) / 10,
                eai: Math.round(wEai * 10) / 10,
                composite: Math.round(wComp * 10) / 10
            };
        }
        /**
         * Recalculate a night's aggregate values from its sessions (respecting _includedInDay).
         * Returns a new night data object.
         */
        function recalculateNightFromSessions(sleepNightDate, allSessions) {
            const included = allSessions.filter(s => s._includedInDay);
            if (included.length === 0) {
                // If nothing is included, return a zeroed-out night
                return {
                    date: sleepNightDate,
                    startTime: 'N/A', endTime: 'N/A',
                    duration: 0, sessions: allSessions.length,
                    _allSessions: allSessions,
                    weightedGI: { overall: 0, skew: 0, spike: 0, flatTop: 0, topHeavy: 0, multiPeak: 0, noPause: 0, inspirRate: 0, multiBreath: 0, ampVar: 0 },
                    machineType: allSessions[0]?.machineType || 'Unknown',
                    ipap: 'N/A', epap: 'N/A', minIPAP: 'N/A', maxIPAP: 'N/A',
                    minEPAP: 'N/A', maxEPAP: 'N/A', pressureSupport: 'N/A',
                    papMode: 'Unknown', riseTime: 'N/A', trigger: 'N/A',
                    cycle: 'N/A', easyBreathe: 'N/A'
                };
            }

            const totalDuration = included.reduce((sum, s) => sum + s.duration, 0);

            // Weighted GI
            const weightedGI = { overall: 0, skew: 0, spike: 0, flatTop: 0, topHeavy: 0, multiPeak: 0, noPause: 0, inspirRate: 0, multiBreath: 0, ampVar: 0 };
            const giKeys = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];

            included.forEach(session => {
                const weight = session.duration / totalDuration;
                giKeys.forEach(key => { weightedGI[key] += session.cumIndex[key] * weight; });
            });

            giKeys.forEach(key => { weightedGI[key] = Math.round(weightedGI[key] * 100) / 100; });
            weightedGI.overall = Math.round(giKeys.reduce((sum, k) => sum + weightedGI[k], 0) * 100) / 100;

            // Sort included by start time
            included.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));

            // Pressures
            // Pressures
            const avgField = (field) => {
                const valid = included.filter(s => s[field] !== 'N/A' && !isNaN(parseFloat(s[field])));
                if (valid.length === 0) return 'N/A';
                const totalD = valid.reduce((sum, s) => sum + s.duration, 0);
                if (totalD <= 0) return valid[0][field];
                return Math.round(valid.reduce((sum, s) => sum + parseFloat(s[field]) * (s.duration / totalD), 0) * 10) / 10;
            };

            const weightedIPAP = avgField('ipap');
            const weightedEPAP = avgField('epap');
            const minIPAP = avgField('minIPAP');
            const maxIPAP = avgField('maxIPAP');
            const minEPAP = avgField('minEPAP');
            const maxEPAP = avgField('maxEPAP');
            let pressureSupport = avgField('ps');

            if (pressureSupport === 'N/A' && weightedIPAP !== 'N/A' && weightedEPAP !== 'N/A') {
                pressureSupport = Math.round((weightedIPAP - weightedEPAP) * 10) / 10;
            }

            const nightMode = included[0]?.papMode || 'Unknown';

            // Settings
            let weightedRiseTime = 'N/A', weightedTrigger = 'N/A', weightedCycle = 'N/A', weightedEasyBreathe = 'N/A';

            const validRise = included.filter(s => s.riseTime !== 'N/A' && !isNaN(parseFloat(s.riseTime)));
            if (validRise.length > 0) {
                const total = validRise.reduce((sum, s) => sum + s.duration, 0);
                if (total > 0) weightedRiseTime = Math.round(validRise.reduce((sum, s) => sum + parseFloat(s.riseTime) * (s.duration / total), 0));
            }
            const validTrig = included.filter(s => s.trigger !== 'N/A' && !isNaN(parseFloat(s.trigger)));
            if (validTrig.length > 0) {
                const total = validTrig.reduce((sum, s) => sum + s.duration, 0);
                if (total > 0) weightedTrigger = Math.round(validTrig.reduce((sum, s) => sum + parseFloat(s.trigger) * (s.duration / total), 0));
            }
            const validCycleArr = included.filter(s => s.cycle !== 'N/A' && !isNaN(parseFloat(s.cycle)));
            if (validCycleArr.length > 0) {
                const total = validCycleArr.reduce((sum, s) => sum + s.duration, 0);
                if (total > 0) weightedCycle = Math.round(validCycleArr.reduce((sum, s) => sum + parseFloat(s.cycle) * (s.duration / total), 0));
            }
            const validEB = included.filter(s => typeof s.easyBreathe === 'string');
            if (validEB.length > 0) {
                const onDur = validEB.filter(s => s.easyBreathe === 'On').reduce((sum, s) => sum + s.duration, 0);
                const offDur = validEB.filter(s => s.easyBreathe === 'Off').reduce((sum, s) => sum + s.duration, 0);
                if (onDur > 0 || offDur > 0) weightedEasyBreathe = onDur >= offDur ? 'On' : 'Off';
            }
            if (weightedEasyBreathe === 'On') weightedRiseTime = 'N/A';

            const earliestSession = included[0];
            const earliestStartTime = earliestSession.startDateTime ?
                formatDateTimeAMPM(earliestSession.startDateTime) :
                formatTimeAMPM(earliestSession.time);
            const latestSession = included[included.length - 1];
            const latestEndTime = latestSession.endDateTime ?
                formatDateTimeAMPM(latestSession.endDateTime) : 'N/A';

            return {
                date: sleepNightDate,
                startTime: earliestStartTime,
                endTime: latestEndTime,
                duration: totalDuration,
                sessions: allSessions.length,
                _allSessions: allSessions,
                weightedGI: weightedGI,
                _wobbleAvg: computeWeightedWobble(included, totalDuration),
                machineType: included[0]?.machineType || 'Unknown',
                ipap: weightedIPAP, epap: weightedEPAP,
                minIPAP, maxIPAP, minEPAP, maxEPAP,
                pressureSupport,
                papMode: nightMode,
                riseTime: weightedRiseTime,
                trigger: weightedTrigger,
                cycle: weightedCycle,
                easyBreathe: weightedEasyBreathe
            };
        }

        // Format time as 12-hour with AM/PM
        function formatTimeAMPM(timeStr) {
            if (!timeStr || timeStr === 'Unknown') return timeStr;
            // Handle HH:MM:SS or HH:MM format
            const parts = timeStr.split(':');
            if (parts.length < 2) return timeStr;

            let hours = parseInt(parts[0], 10);
            const minutes = parts[1];
            const seconds = parts.length > 2 ? ':' + parts[2] : '';

            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12

            return `${hours}:${minutes}${seconds} ${ampm}`;
        }

        // Format Date object to 12-hour AM/PM string
        function formatDateTimeAMPM(date) {
            if (!date || !(date instanceof Date)) return 'Unknown';

            let hours = date.getHours();
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');

            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12;

            return `${hours}:${minutes}:${seconds} ${ampm}`;
        }

        // File handling
        document.getElementById('fileInput').addEventListener('change', function (event) {
            const files = Array.from(event.target.files);
            handleFiles(files);
        });

        // Folder handling
        document.getElementById('folderInput').addEventListener('change', function (event) {
            const files = Array.from(event.target.files);
            handleFiles(files);
        });

        // Enhanced drag and drop functionality
        const uploadSection = document.getElementById('uploadSection');

        uploadSection.addEventListener('dragover', function (e) {
            e.preventDefault();
            uploadSection.classList.add('drag-over');
        });

        uploadSection.addEventListener('dragleave', function (e) {
            e.preventDefault();
            uploadSection.classList.remove('drag-over');
        });

        uploadSection.addEventListener('drop', function (e) {
            e.preventDefault();
            uploadSection.classList.remove('drag-over');

            const files = [];
            const items = e.dataTransfer.items;

            if (items) {
                // Handle both files and directories
                const promises = [];

                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry();
                        if (entry) {
                            promises.push(processEntry(entry));
                        }
                    }
                }

                Promise.all(promises).then(results => {
                    const allFiles = results.flat();
                    if (allFiles.length > 0) {
                        handleFiles(allFiles);
                    } else {
                        alert('No supported files found. Please drop folders containing ResMed (.edf) or Philips (.005) data.');
                    }
                });
            } else {
                // Fallback for browsers that don't support webkitGetAsEntry
                const fileList = Array.from(e.dataTransfer.files).filter(file => file.name.endsWith('.edf'));
                if (fileList.length > 0) {
                    handleFiles(fileList);
                }
            }
        });

        // Process directory entries recursively
        function processEntry(entry) {
            return new Promise((resolve) => {
                if (entry.isFile) {
                    entry.file(resolve);
                } else if (entry.isDirectory) {
                    const dirReader = entry.createReader();
                    dirReader.readEntries((entries) => {
                        const promises = entries.map(processEntry);
                        Promise.all(promises).then(results => {
                            resolve(results.flat());
                        });
                    });
                }
            });
        }

        // ============ Philips PRS1 Data Parser ============
        // Ported from philips_loader.py ‚Äî supports DreamStation .005 waveform files
        // File structure: P-SERIES/<serial>/P0/<hex>.001 (header), .002 (events), .005 (waveforms)

        function isPhilipsDataSet(files) {
            // Detect Philips by presence of .005 waveform files or P-SERIES folder structure
            return files.some(f => /\.\d{3}$/.test(f.name) && f.name.endsWith('.005')) ||
                files.some(f => f.webkitRelativePath && f.webkitRelativePath.includes('P-SERIES'));
        }

        /**
         * Parse a Philips PRS1 .001 header file to extract session timestamp.
         * The timestamp is a uint32 at offset 11-14 (little-endian Unix epoch).
         */
        function parsePhilipsHeader(arrayBuffer) {
            const data = new Uint8Array(arrayBuffer);
            if (data.length < 15) return null;

            // Read timestamp: little-endian uint32 at offset 11
            const ts = data[11] | (data[12] << 8) | (data[13] << 16) | (data[14] << 24);
            const startDateTime = new Date(ts * 1000);

            // Read duration hint if available (offset varies by version)
            return {
                startDateTime: startDateTime,
                timestamp: ts
            };
        }

        /**
         * Parse a Philips PRS1 .005 waveform file to extract flow data.
         * Ported from OSCAR's prs1_parser.cpp / prs1_loader.cpp.
         *
         * PRS1 .005 file format:
         * - Multiple blocks (chunks), each with:
         *   - 15 bytes common header: fileVersion(1), blockSize(2), htype(1), family(1),
         *     familyVersion(1), ext(1), sessionid(4), timestamp(4)
         *   - Waveform header (when htype=1): interval_count(2), interval_seconds(1),
         *     num_channels(1), per-channel: kind(1), interleave(2), [sample_bits(1) for V3]
         *   - 1 byte header checksum
         *   - Data block (blockSize - headerSize bytes)
         *   - CRC16 (V2) or CRC32 (V3) at end of data
         *
         * Flow data: signed 8-bit values, gain=1.0, offset=0.0 ‚Üí values ARE L/min directly.
         * For multi-channel .005 files, channel 0 is flow (signed char), channel 1 is pressure.
         *
         * Returns: { flowSamples: number[], sampleRateHz: number, duration: number }
         */
        function parsePhilipsWaveform(arrayBuffer) {
            const data = new Uint8Array(arrayBuffer);
            if (!data || data.length < 20) return null;

            // Check for DreamStation 2 encrypted format
            if (data.length >= 6 && data[0] === 0x0d && data[1] === 0x01 && data[2] === 0x01) {
                console.warn('DreamStation 2 encrypted files are not yet supported in browser');
                return null;
            }

            const flowSamples = [];
            let detectedSampleRate = 0;
            let totalDuration = 0;
            let pos = 0;

            // Parse blocks/chunks
            while (pos + 15 <= data.length) {
                const blockStart = pos;

                // --- Common header (15 bytes) ---
                const fileVersion = data[pos];       // Should be 2 or 3
                const blockSize = data[pos + 1] | (data[pos + 2] << 8);
                const htype = data[pos + 3];          // 0=normal, 1=waveform/interval
                const family = data[pos + 4];
                const familyVersion = data[pos + 5];
                const ext = data[pos + 6];
                // sessionid at [7..10], timestamp at [11..14]

                // Sanity checks
                if (fileVersion < 2 || fileVersion > 3) {
                    console.warn(`PRS1 block at ${pos}: unsupported fileVersion ${fileVersion}, stopping`);
                    break;
                }
                if (blockSize === 0 || blockSize > data.length - blockStart) {
                    console.warn(`PRS1 block at ${pos}: blockSize ${blockSize} exceeds file, stopping`);
                    break;
                }

                pos += 15; // past common header

                if (htype !== 1) {
                    // Not a waveform chunk (normal chunk)
                    // Skip to end of block based on fileVersion
                    if (fileVersion === 3) {
                        // V3 has extra header fields: 1 byte count + count*2 bytes key-value pairs
                        if (pos < data.length) {
                            const hdbLen = data[pos];
                            pos += 1 + hdbLen * 2;
                        }
                    }
                    // Skip 1 byte header checksum + remaining data
                    pos = blockStart + blockSize;
                    continue;
                }

                // --- Waveform header ---
                if (pos + 4 > data.length) break;

                const intervalCount = data[pos] | (data[pos + 1] << 8);  // number of intervals
                const intervalSeconds = data[pos + 2];                    // seconds per interval
                const numChannels = data[pos + 3];                        // number of waveform channels
                pos += 4;

                const duration = intervalCount * intervalSeconds;
                totalDuration += duration;

                // Parse per-channel waveform info
                const channels = [];
                const wsSize = (fileVersion === 3) ? 4 : 3;
                for (let ch = 0; ch < numChannels; ch++) {
                    if (pos + wsSize > data.length) break;
                    const kind = data[pos];
                    const interleave = data[pos + 1] | (data[pos + 2] << 8); // samples per interval
                    // fileVersion 3 has an extra byte (sample size in bits, always 8)
                    channels.push({ kind, interleave });
                    pos += wsSize;
                }

                // Skip trailing byte (always 0) + 1 byte header checksum
                pos += 2;  // trailing byte + checksum

                // Calculate data size
                const headerSize = pos - blockStart;
                let dataSize = blockSize - headerSize;
                // CRC at end: 2 bytes for V2, 4 bytes for V3
                const crcSize = (fileVersion === 3) ? 4 : 2;
                dataSize -= crcSize;

                if (dataSize <= 0 || pos + dataSize > data.length) {
                    pos = blockStart + blockSize;
                    continue;
                }

                const dataStart = pos;

                // Determine sample rate from first channel
                if (channels.length > 0 && intervalSeconds > 0) {
                    const sampleRate = channels[0].interleave / intervalSeconds;
                    if (detectedSampleRate === 0) {
                        detectedSampleRate = sampleRate;
                        console.log(`PRS1 waveform: ${numChannels} channels, ` +
                            `${channels[0].interleave} samples/interval, ` +
                            `${intervalSeconds}s intervals ‚Üí ${sampleRate} Hz, ` +
                            `family F${family}V${familyVersion}`);
                    }
                }

                // Calculate total interleave stride (bytes per sample group)
                const totalInterleave = channels.reduce((sum, ch) => sum + ch.interleave, 0);

                if (numChannels > 1 && totalInterleave > 0) {
                    // Multi-channel: de-interleave to extract flow (channel 0)
                    // Each "sample group" has channels[0].interleave bytes of flow,
                    // then channels[1].interleave bytes of pressure, etc.
                    const flowInterleave = channels[0].interleave;
                    const numGroups = Math.floor(dataSize / totalInterleave);

                    for (let g = 0; g < numGroups; g++) {
                        const groupStart = dataStart + g * totalInterleave;
                        for (let s = 0; s < flowInterleave; s++) {
                            const byteIdx = groupStart + s;
                            if (byteIdx >= data.length) break;
                            // Signed 8-bit: raw value IS L/min (gain=1.0, offset=0.0)
                            let val = data[byteIdx];
                            if (val > 127) val -= 256;  // Convert to signed
                            flowSamples.push(val);
                        }
                    }
                } else if (numChannels === 1 && channels.length > 0) {
                    // Single channel: all data is flow
                    for (let i = 0; i < dataSize; i++) {
                        const byteIdx = dataStart + i;
                        if (byteIdx >= data.length) break;
                        let val = data[byteIdx];
                        if (val > 127) val -= 256;  // Signed 8-bit
                        flowSamples.push(val);
                    }
                }

                // Skip to next block
                pos = blockStart + blockSize;
            }

            if (flowSamples.length === 0) {
                console.warn('No flow data found in PRS1 waveform file');
                return null;
            }

            const sampleRateHz = detectedSampleRate || 5;  // Default 5 Hz per OSCAR (.005 interleave=5)
            console.log(`PRS1 parsed: ${flowSamples.length} flow samples, ` +
                `${sampleRateHz} Hz, ${totalDuration}s duration, ` +
                `value range [${Math.min(...flowSamples.slice(0, 1000))}, ${Math.max(...flowSamples.slice(0, 1000))}]`);

            return {
                flowSamples: flowSamples,
                sampleRateHz: sampleRateHz,
                duration: totalDuration
            };
        }

        /**
         * Parse PROP.TXT for machine identification
         */
        function parsePhilipsProp(text) {
            const props = {};
            text.split('\n').forEach(line => {
                const eq = line.indexOf('=');
                if (eq > 0) {
                    props[line.slice(0, eq).trim()] = line.slice(eq + 1).trim();
                }
            });
            return {
                serial: props.SN || 'Unknown',
                model: props.MN || 'Unknown',
                type: `Philips ${props.MN || 'DreamStation'}`,
                firmware: props.SV || 'Unknown'
            };
        }

        /**
         * Process a set of Philips files: group .001/.005 pairs by session, parse waveforms,
         * run GI + Wobble analysis on each session.
         */
        async function processPhilipsFiles(files) {
            // Append to existing results instead of wiping (merge uploads)

            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const processingStatus = document.getElementById('processingStatus');

            progressBar.style.display = 'block';

            // Find PROP.TXT for machine info
            let machineInfo = { type: 'Philips DreamStation' };
            const propFile = files.find(f => f.name === 'PROP.TXT');
            if (propFile) {
                try {
                    const text = await propFile.text();
                    machineInfo = parsePhilipsProp(text);
                    processingStatus.textContent = `Detected: ${machineInfo.type} (${machineInfo.serial})`;
                } catch (e) {
                    console.warn('Could not parse PROP.TXT:', e);
                }
            }

            // Group files by session (same hex prefix)
            const sessionMap = {};
            files.forEach(f => {
                const match = f.name.match(/^([0-9A-Fa-f]+)\.(\d{3})$/);
                if (match) {
                    const sessionId = match[1];
                    const ext = match[2];
                    if (!sessionMap[sessionId]) sessionMap[sessionId] = {};
                    sessionMap[sessionId][ext] = f;
                }
            });

            const sessionIds = Object.keys(sessionMap).sort();
            const waveformSessions = sessionIds.filter(id => sessionMap[id]['005']);

            processingStatus.textContent = `Found ${waveformSessions.length} Philips sessions with waveform data`;
            document.getElementById('fileCount').textContent =
                `Found ${waveformSessions.length} Philips waveform sessions (${sessionIds.length} total sessions)`;

            let cacheHits = 0;
            let cacheMisses = 0;

            for (let i = 0; i < waveformSessions.length; i++) {
                const sessionId = waveformSessions[i];
                const session = sessionMap[sessionId];
                const progress = ((i + 1) / waveformSessions.length) * 100;
                progressFill.style.width = progress + '%';

                const cacheKey = `philips_${sessionId}.005`;

                try {
                    // Check cache first
                    const cached = await getCachedResult(cacheKey);
                    if (cached) {
                        nightlyResults.push(cached);
                        cacheHits++;
                        processingStatus.textContent = `[cached] ${sessionId} (${i + 1}/${waveformSessions.length})`;
                        await new Promise(resolve => setTimeout(resolve, 5));
                        continue;
                    }

                    processingStatus.textContent = `Processing Philips ${sessionId} (${i + 1}/${waveformSessions.length})...`;

                    // Parse header for timestamp
                    let startDateTime = new Date();
                    if (session['001']) {
                        const headerBuf = await session['001'].arrayBuffer();
                        const headerInfo = parsePhilipsHeader(headerBuf);
                        if (headerInfo && headerInfo.startDateTime) {
                            startDateTime = headerInfo.startDateTime;
                        }
                    }

                    // Parse waveform
                    const wavBuf = await session['005'].arrayBuffer();
                    const waveResult = parsePhilipsWaveform(wavBuf);

                    if (!waveResult || waveResult.flowSamples.length < 100) {
                        console.warn(`Session ${sessionId}: insufficient flow data (${waveResult ? waveResult.flowSamples.length : 0} samples)`);
                        continue;
                    }

                    const flowValues = waveResult.flowSamples;
                    const sampleRateHz = waveResult.sampleRateHz;
                    // Note: flow values are already in L/min (signed 8-bit, gain=1.0, offset=0.0)
                    // No scaling needed ‚Äî this matches OSCAR's import format exactly

                    // Convert to the same [{x, y}] format as ResMed data
                    const dataArray = [];
                    let sampleDateTime = new Date(startDateTime.getTime());
                    const sampleIntervalMs = 1000 / sampleRateHz;

                    for (let s = 0; s < flowValues.length; s++) {
                        dataArray.push({
                            x: formatChartDate(sampleDateTime),
                            y: flowValues[s]
                        });
                        sampleDateTime = new Date(sampleDateTime.getTime() + sampleIntervalMs);
                    }

                    // Run Glasgow Index analysis
                    const results = {};
                    findMins(dataArray);
                    findInspirations(dataArray, results);
                    calcCycleBasedIndicators(dataArray, results);
                    prepIdealFlow(dataArray, results);
                    inspirationAmplitude(dataArray, results);
                    results.cumIndex = prepIndices(results);

                    // Run Wobble analysis
                    let wobbleMetrics = { sampleEntropy: NaN, periodicityScore: 0, breathsPerMin: 0, dominantFreqHz: 0 };
                    try {
                        wobbleMetrics = runWobbleAnalysis(dataArray, sampleRateHz);
                    } catch (e) {
                        console.warn('Wobble analysis failed for Philips session ' + sessionId + ':', e);
                    }

                    // Calculate duration
                    const durationMs = flowValues.length * sampleIntervalMs;
                    const durationHours = durationMs / (1000 * 60 * 60);

                    // Format date
                    const date = startDateTime.toISOString().split('T')[0];
                    const time = `${String(startDateTime.getHours()).padStart(2, '0')}:${String(startDateTime.getMinutes()).padStart(2, '0')}:${String(startDateTime.getSeconds()).padStart(2, '0')}`;

                    // Determine sleep night date
                    const sessionHour = startDateTime.getHours();
                    let sleepNightDate;
                    if (sessionHour >= 18) {
                        sleepNightDate = date;
                    } else if (sessionHour < 12) {
                        const prevDate = new Date(startDateTime);
                        prevDate.setDate(prevDate.getDate() - 1);
                        sleepNightDate = prevDate.toISOString().split('T')[0];
                    } else {
                        sleepNightDate = date;
                    }

                    const result = {
                        fileName: cacheKey,
                        date: date,
                        time: time,
                        sleepNightDate: sleepNightDate,
                        _hasFolderDate: false,
                        startDateTime: startDateTime,
                        endDateTime: new Date(startDateTime.getTime() + durationHours * 60 * 60 * 1000),
                        duration: durationHours,
                        cumIndex: results.cumIndex,
                        wobble: wobbleMetrics,
                        inspirationCount: results.inspirations ? results.inspirations.length : 0,
                        inspirations: results.inspirations || [],
                        flowData: dataArray,              // Raw flow data for heatmap click-to-inspect
                        idealData: results.idealArray || [], // Idealized flow for click detail overlay
                        sampleCount: dataArray.length,
                        machineType: machineInfo.type,
                        ipap: 'N/A', epap: 'N/A', minIPAP: 'N/A', maxIPAP: 'N/A',
                        minEPAP: 'N/A', maxEPAP: 'N/A', ps: 'N/A',
                        papMode: 'Unknown',
                        riseTime: 'N/A', trigger: 'N/A', cycle: 'N/A', easyBreathe: 'N/A'
                    };

                    nightlyResults.push(result);
                    await setCachedResult(result);
                    cacheMisses++;

                } catch (error) {
                    console.error(`Error processing Philips session ${sessionId}:`, error);
                }

                await new Promise(resolve => setTimeout(resolve, 50));
            }

            progressBar.style.display = 'none';
            const cacheMsg = cacheHits > 0 ? ` (${cacheHits} cached, ${cacheMisses} new)` : '';
            processingStatus.textContent = `Done ‚Äî ${nightlyResults.length} Philips sessions processed${cacheMsg}`;

            if (nightlyResults.length > 0) {
                displayResults();
            } else {
                alert('No Philips waveform files could be processed. Ensure your folder contains .005 files.');
            }
        }

        function handleFiles(files) {
            // Auto-detect Philips data
            if (isPhilipsDataSet(files)) {
                console.log('Detected Philips data set ‚Äî routing to Philips processor');
                processPhilipsFiles(files);
                return;
            }

            const brpFiles = files.filter(file => file.name.includes('_BRP.edf'));
            const eveFiles = files.filter(file => file.name.includes('_EVE.edf'));
            const identificationFiles = files.filter(file =>
                file.name === 'Identification.tgt' ||
                file.name === 'Identification.json'
            );
            const strFiles = files.filter(file => file.name === 'STR.edf');
            const allEdfFiles = files.filter(file => file.name.endsWith('.edf'));

            if (brpFiles.length === 0) {
                if (allEdfFiles.length > 0) {
                    const otherTypes = allEdfFiles.map(f => {
                        if (f.name.includes('_PLD.edf')) return 'PLD (pressure data)';
                        if (f.name.includes('_SAD.edf')) return 'SAD (summary data)';
                        if (f.name.includes('_EVE.edf')) return 'EVE (event data)';
                        return 'unknown type';
                    });

                    alert(`Found ${allEdfFiles.length} EDF files, but none are BRP (breathing) files needed for analysis.\n\nFound: ${[...new Set(otherTypes)].join(', ')}\n\nPlease ensure your folders contain BRP.edf files from your ResMed device.`);
                } else {
                    alert('No EDF files found. Please select folders containing ResMed data or individual BRP.edf files.');
                }
                return;
            }

            // Extract folder-based sleep night date from webkitRelativePath if available
            // Path format: DATALOG/20250724/20250724_232010_BRP.edf
            // The folder name (20250724) represents the sleep night, even if file timestamps cross midnight
            function extractFolderDate(file) {
                if (file.webkitRelativePath) {
                    // Match folder name in format YYYYMMDD from path like "DATALOG/20250724/filename.edf"
                    const pathMatch = file.webkitRelativePath.match(/\/(\d{8})\//);
                    if (pathMatch) {
                        return pathMatch[1];
                    }
                }
                return null;
            }

            // Group files by night to show better summary (prefer folder date over filename date)
            const nightGroups = {};
            brpFiles.forEach(file => {
                // Try folder date first, fall back to filename date
                let date = extractFolderDate(file);
                if (!date) {
                    const match = file.name.match(/(\d{8})_/);
                    if (match) date = match[1];
                }
                if (date) {
                    if (!nightGroups[date]) nightGroups[date] = 0;
                    nightGroups[date]++;
                }
            });

            const nightCount = Object.keys(nightGroups).length;
            const sessionCount = brpFiles.length;

            let countText = `Found ${sessionCount} breathing data files from ${nightCount} night${nightCount !== 1 ? 's' : ''}`;

            if (allEdfFiles.length > brpFiles.length) {
                const otherCount = allEdfFiles.length - brpFiles.length;
                countText += ` (${otherCount} other EDF files ignored)`;
            }

            // Show which nights were found
            if (nightCount <= 10) {
                const nightDates = Object.keys(nightGroups).sort().map(date => {
                    const sessionCount = nightGroups[date];
                    const formattedDate = `${date.slice(0, 4)}-${date.slice(4, 6)}-${date.slice(6, 8)}`;
                    return sessionCount > 1 ? `${formattedDate} (${sessionCount} sessions)` : formattedDate;
                });
                countText += `\n\nNights: ${nightDates.join(', ')}`;
            }

            document.getElementById('fileCount').textContent = countText;

            // Attach folder date to each file for use during processing
            brpFiles.forEach(file => {
                file._folderDate = extractFolderDate(file);
            });

            processFiles(brpFiles, identificationFiles, strFiles);
        }

        async function processFiles(brpFiles, identificationFiles = [], strFiles = []) {
            // Append to existing results instead of wiping (merge uploads)

            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const processingStatus = document.getElementById('processingStatus');

            progressBar.style.display = 'block';

            // Parse machine identification first
            let machineInfo = null;
            if (identificationFiles.length > 0) {
                try {
                    processingStatus.textContent = 'Reading machine identification...';
                    machineInfo = await parseMachineIdentification(identificationFiles[0]);
                    console.log('Detected machine:', machineInfo);
                } catch (error) {
                    console.error('Error parsing machine identification:', error);
                }
            }

            // Parse STR file for pressure settings
            let pressureSettings = null;
            if (strFiles.length > 0) {
                try {
                    processingStatus.textContent = 'Reading pressure settings...';
                    pressureSettings = await parseSTRFile(strFiles[0]);
                    console.log('Extracted pressure settings:', pressureSettings);
                } catch (error) {
                    console.error('Error parsing STR file:', error);
                }
            }

            let cacheHits = 0;
            let cacheMisses = 0;

            for (let i = 0; i < brpFiles.length; i++) {
                const file = brpFiles[i];
                const progress = ((i + 1) / brpFiles.length) * 100;
                progressFill.style.width = progress + '%';

                try {
                    // Check cache first
                    const cached = await getCachedResult(file.name);
                    if (cached) {
                        // Restore folder date context for grouping
                        if (file._folderDate && !cached._hasFolderDate) {
                            cached.sleepNightDate = `${file._folderDate.slice(0, 4)}-${file._folderDate.slice(4, 6)}-${file._folderDate.slice(6, 8)}`;
                            cached._hasFolderDate = true;
                        }
                        nightlyResults.push(cached);
                        cacheHits++;
                        processingStatus.textContent = `[cached] ${file.name} (${i + 1}/${brpFiles.length})`;
                        // Minimal delay for cached results
                        await new Promise(resolve => setTimeout(resolve, 5));
                    } else {
                        processingStatus.textContent = `Processing ${file.name} (${i + 1}/${brpFiles.length})...`;
                        const result = await processFile(file, machineInfo, pressureSettings);
                        if (result) {
                            nightlyResults.push(result);
                            // Cache the result for next time
                            await setCachedResult(result);
                            cacheMisses++;
                        }
                        // Small delay to allow UI to update
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                }
            }

            progressBar.style.display = 'none';
            const cacheMsg = cacheHits > 0 ? ` (${cacheHits} cached, ${cacheMisses} new)` : '';
            processingStatus.textContent = cacheMsg ? `Done${cacheMsg}` : '';

            if (nightlyResults.length > 0) {
                displayResults();
            } else {
                alert('No files could be processed successfully');
            }
        }

        function processFile(file, machineInfo = null, pressureSettings = null) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = function (event) {
                    try {
                        const arrayBuffer = event.target.result;
                        // Pass folder date for accurate sleep night grouping
                        const result = analyzeFile(arrayBuffer, file.name, machineInfo, pressureSettings, file._folderDate);
                        resolve(result);
                    } catch (error) {
                        console.error(`Error processing file ${file.name}:`, error);
                        resolve(null);
                    }
                };

                reader.onerror = function () {
                    reject(new Error(`Failed to read file ${file.name}`));
                };

                reader.readAsArrayBuffer(file);
            });
        }

        function analyzeFile(arrayBuffer, fileName, machineInfo = null, pressureSettings = null, folderDate = null) {
            // Parse EDF file
            const fileData = parseEDFFile(arrayBuffer);
            if (fileData.formatVersion !== "0") {
                throw new Error("Incorrect file format");
            }

            // Extract flow data
            const dataArray = formDataArray(fileData);
            if (!dataArray || dataArray.length === 0) {
                throw new Error("No flow data found");
            }

            // Run Glasgow Index analysis
            const results = {};

            findMins(dataArray);
            findInspirations(dataArray, results);
            calcCycleBasedIndicators(dataArray, results);
            prepIdealFlow(dataArray, results);
            inspirationAmplitude(dataArray, results);
            results.cumIndex = prepIndices(results);

            // Run Wobble analysis (sample entropy, FFT periodicity)
            const sampleRateHz = fileData.signals.find(s => s.label && s.label.includes('Flow'))
                ? Math.round(1000 / fileData.signals.find(s => s.label && s.label.includes('Flow')).sampleIntervalmS)
                : 25;
            let wobbleMetrics = { sampleEntropy: NaN, periodicityScore: 0, breathsPerMin: 0, dominantFreqHz: 0 };
            try {
                wobbleMetrics = runWobbleAnalysis(dataArray, sampleRateHz);
            } catch (e) {
                console.warn('Wobble analysis failed for ' + fileName + ':', e);
            }

            // Calculate session duration in hours
            const durationMs = dataArray.length * 40; // 40ms per sample
            const durationHours = durationMs / (1000 * 60 * 60);

            // Extract date and time from filename (for session timestamp display)
            const match = fileName.match(/(\d{8})_(\d{6})_BRP\.edf/);
            let date = 'Unknown';
            let time = 'Unknown';

            if (match) {
                const dateStr = match[1];
                const timeStr = match[2];

                date = `${dateStr.slice(0, 4)}-${dateStr.slice(4, 6)}-${dateStr.slice(6, 8)}`;
                time = `${timeStr.slice(0, 2)}:${timeStr.slice(2, 4)}:${timeStr.slice(4, 6)}`;
            }

            // Determine sleep night date: prefer folder date (from DATALOG/YYYYMMDD/ structure)
            // The folder name represents the night the user went to sleep, even if the session
            // crosses midnight. Fall back to heuristic-based calculation if no folder date.
            let sleepNightDate;
            if (folderDate) {
                // Use folder date directly - format as YYYY-MM-DD
                sleepNightDate = `${folderDate.slice(0, 4)}-${folderDate.slice(4, 6)}-${folderDate.slice(6, 8)}`;
            } else {
                // Fallback: calculate from session start time using heuristics
                // Sessions 6 PM - midnight = current date's night
                // Sessions midnight - noon = previous date's night
                const sessionDateTime = fileData.startDateTime;
                if (sessionDateTime) {
                    const sessionHour = sessionDateTime.getHours();
                    if (sessionHour >= 18) {
                        sleepNightDate = date;
                    } else if (sessionHour < 12) {
                        const prevDate = new Date(sessionDateTime);
                        prevDate.setDate(prevDate.getDate() - 1);
                        sleepNightDate = prevDate.toISOString().split('T')[0];
                    } else {
                        sleepNightDate = date;
                    }
                } else {
                    sleepNightDate = date;
                }
            }

            // Extract pressure data for this session date
            let sessionPressure = getSessionPressureData(pressureSettings, date);
            // Extract additional machine settings from pressureSettings (per-date), if available
            const sessionExtras = sessionPressure || {};

            // Apply EasyBreathe logic at the session level: if On, Rise Time is N/A
            const easyOn = (sessionExtras && typeof sessionExtras.easyBreathe === 'string' && sessionExtras.easyBreathe === 'On');
            const finalRiseTime = easyOn ? 'N/A' : ((sessionExtras && sessionExtras.riseTime !== undefined) ? sessionExtras.riseTime : 'N/A');

            return {
                fileName: fileName,
                date: date,
                time: time,
                sleepNightDate: sleepNightDate,  // The night this session belongs to (from folder or heuristic)
                _hasFolderDate: !!folderDate,    // Flag indicating if this was from folder structure (trusted)
                startDateTime: fileData.startDateTime,
                endDateTime: new Date(fileData.startDateTime.getTime() + durationHours * 60 * 60 * 1000),
                duration: durationHours,
                cumIndex: results.cumIndex,
                wobble: wobbleMetrics,            // MegaScore: Wobble analysis results
                inspirationCount: results.inspirations ? results.inspirations.length : 0,
                inspirations: results.inspirations || [],
                flowData: dataArray,              // Raw flow data for heatmap click-to-inspect
                idealData: results.idealArray || [], // Idealized flow for click detail overlay
                sampleCount: (results.inspirations && results.inspirations.length > 0) ? results.inspirations[results.inspirations.length - 1].end : (dataArray ? dataArray.length : 0),
                machineType: machineInfo ? machineInfo.type : 'Unknown',
                ipap: sessionPressure && sessionPressure.ipap !== undefined ? sessionPressure.ipap : 'N/A',
                epap: sessionPressure && sessionPressure.epap !== undefined ? sessionPressure.epap : 'N/A',
                minIPAP: sessionPressure && sessionPressure.minIPAP !== undefined ? sessionPressure.minIPAP : 'N/A',
                maxIPAP: sessionPressure && sessionPressure.maxIPAP !== undefined ? sessionPressure.maxIPAP : 'N/A',
                minEPAP: sessionPressure && sessionPressure.minEPAP !== undefined ? sessionPressure.minEPAP : 'N/A',
                maxEPAP: sessionPressure && sessionPressure.maxEPAP !== undefined ? sessionPressure.maxEPAP : 'N/A',
                ps: sessionPressure && sessionPressure.ps !== undefined ? sessionPressure.ps : 'N/A',
                papMode: sessionPressure ? sessionPressure.mode : 'Unknown',
                riseTime: finalRiseTime,
                trigger: (sessionExtras && sessionExtras.trigger !== undefined) ? sessionExtras.trigger : 'N/A',
                cycle: (sessionExtras && sessionExtras.cycle !== undefined) ? sessionExtras.cycle : 'N/A',
                easyBreathe: (sessionExtras && sessionExtras.easyBreathe !== undefined) ? sessionExtras.easyBreathe : 'N/A'
            };
        }

        function displayResults() {
            // Deduplicate in case same files were uploaded again
            deduplicateResults();

            // Sort results by date/time
            nightlyResults.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));

            // Group by night (same date, combine sessions)
            const nightlyData = groupByNight(nightlyResults);
            window.originalNightlyData = nightlyData; // Store for dynamic recalculation

            // Collapse upload section after successful data load
            const uploadSection = document.getElementById('uploadSection');
            if (uploadSection) uploadSection.open = false;

            // Update summary cards
            updateSummaryCards(nightlyData);

            // Create charts
            createTrendsChart(nightlyData);
            createComponentsChart(nightlyData);

            // Create results table
            createResultsTable(nightlyData);

            // Populate selector and render heatmap
            populateNightSelector(nightlyData);
            renderMostRecentNightHeatmap(nightlyData);

            // Show results section
            document.getElementById('resultsSection').style.display = 'block';
        }

        function groupByNight(results) {
            // Smart session grouping: merge sessions that are close in time (within 6 hours gap)
            // This handles ResMed's noon-split where a 4am-2pm sleep gets split at noon
            const MAX_GAP_HOURS = 6; // Maximum gap between sessions to consider them the same night

            // First, sort all sessions by start time
            const sortedResults = [...results].sort((a, b) =>
                new Date(a.startDateTime) - new Date(b.startDateTime)
            );

            // Assign effective sleepNightDate by looking at session gaps
            // If a session starts within 6 hours of the previous session ending,
            // it belongs to the same night
            for (let i = 0; i < sortedResults.length; i++) {
                const session = sortedResults[i];

                // If this session already has a folder-based date, trust it
                if (session._hasFolderDate) continue;

                // Check if this session should be merged with the previous one
                if (i > 0) {
                    const prevSession = sortedResults[i - 1];
                    const prevEndTime = new Date(prevSession.startDateTime);
                    prevEndTime.setTime(prevEndTime.getTime() + prevSession.duration * 60 * 60 * 1000);

                    const currentStartTime = new Date(session.startDateTime);
                    const gapHours = (currentStartTime - prevEndTime) / (1000 * 60 * 60);

                    // If gap is small (within MAX_GAP_HOURS), use the previous session's sleepNightDate
                    // This handles the noon-split case: 4am-12pm and 12pm-2pm should be same night
                    if (gapHours <= MAX_GAP_HOURS && gapHours >= 0) {
                        session.sleepNightDate = prevSession.sleepNightDate;
                    }
                }
            }

            // Group by sleep night
            const grouped = {};
            sortedResults.forEach(result => {
                const sleepNightDate = result.sleepNightDate || result.date;
                if (!grouped[sleepNightDate]) grouped[sleepNightDate] = [];
                grouped[sleepNightDate].push(result);
            });

            // Classify sessions and calculate nightly aggregates
            const nightlyData = [];
            Object.keys(grouped).forEach(sleepNightDate => {
                const sessions = grouped[sleepNightDate];

                // Classify each session (main, noon-split, bathroom, nap)
                classifySessionsForNight(sessions);

                // Build night aggregate using only included sessions
                const night = recalculateNightFromSessions(sleepNightDate, sessions);
                nightlyData.push(night);
            });

            return nightlyData.sort((a, b) => new Date(b.date) - new Date(a.date)); // Most recent first
        }

        // Build and render heatmap for the most recent night by concatenating sessions
        function renderMostRecentNightHeatmap(nightlyData) {
            if (!nightlyData || nightlyData.length === 0) return;

            // Most recent night is first due to sorting in groupByNight
            const mostRecentNightDate = nightlyData[0].date;
            const nightlyWeighted = nightlyData[0].weightedGI;

            // Collect sessions that belong to this sleep night
            const sessions = getSessionsForNight(mostRecentNightDate);
            if (!sessions || sessions.length === 0) return;

            // Sort by start time
            sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));

            // Concatenate inspirations, adjusting sample indices
            let sampleOffset = 0;
            const concatenatedInspirations = [];
            sessions.forEach(session => {
                if (!session.inspirations || session.inspirations.length === 0) return;
                session.inspirations.forEach(insp => {
                    concatenatedInspirations.push({
                        start: (insp.start || 0) + sampleOffset,
                        end: (insp.end || 0) + sampleOffset,
                        indices: insp.indices
                    });
                });
                // Advance offset by this session's length in samples
                const sessionSamples = session.sampleCount || (session.inspirations[session.inspirations.length - 1]?.end || 0);
                sampleOffset += sessionSamples;
            });

            // Prepare globals expected by original displayHeatMap()
            window.startDateTime = new Date(sessions[0].startDateTime);

            // Lazily build flow data only for sessions of this night (not all sessions)
            sessions.forEach(session => ensureFlowData(session));

            // Build concatenated dataArray from session flow data for click-to-inspect
            const allFlowData = [];
            const allIdealData = [];
            sessions.forEach(session => {
                if (session.flowData && session.flowData.length > 0) {
                    for (let j = 0; j < session.flowData.length; j++) {
                        allFlowData.push(session.flowData[j]);
                    }
                    if (session.idealData) {
                        for (let j = 0; j < session.idealData.length; j++) {
                            allIdealData.push(session.idealData[j]);
                        }
                    }
                }
            });
            // Set globals ‚Äî these are used by showDetailOneMinute in FlowLimits.js
            window.dataArray = allFlowData.length > 0 ? allFlowData : null;
            window.results = { idealArray: allIdealData, inspirations: concatenatedInspirations, flowImbalance: [] };

            // Use duration-weighted nightly components for the labels on the left
            const resultsForHeatmap = {
                inspirations: concatenatedInspirations,
                cumIndex: nightlyWeighted,
                idealArray: allIdealData,
                flowImbalance: []
            };

            // Set the global dataArray used by displayHeatMap's click handler
            dataArray = allFlowData.length > 0 ? allFlowData : [];

            try {
                displayHeatMap(resultsForHeatmap);
                // After FlowLimits.js registers its click handler, add our own to show the detail section
                const chartTopEl = document.getElementById('chartTop');
                if (chartTopEl) {
                    chartTopEl.addEventListener('click', function () {
                        // Small delay to let FlowLimits.js create the chart first
                        setTimeout(function () {
                            if (chartDetail) {
                                showDetailSection();
                                // Scroll the detail chart into view
                                document.getElementById('detailChartSection')?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }, 100);
                    }, false);
                }
            } catch (e) {
                console.error('Heatmap render failed:', e);
            }
        }

        // Helper: find sessions in nightlyResults that map to the given sleep night date
        function getSessionsForNight(sleepNightDate) {
            if (!nightlyResults || nightlyResults.length === 0) return [];

            // Use pre-calculated sleepNightDate from each result (from folder name or heuristic fallback)
            return nightlyResults.filter(result =>
                (result.sleepNightDate || result.date) === sleepNightDate
            );
        }

        // Populate night dropdown with date and time info
        function populateNightSelector(nightlyData) {
            const select = document.getElementById('nightSelect');
            if (!select) return;
            select.innerHTML = '';
            nightlyData.forEach(night => {
                const opt = document.createElement('option');
                opt.value = night.date;
                // Show date with start-end time range and duration
                const startTimeFormatted = night.startTime || 'Unknown';
                const endTimeFormatted = night.endTime || '';
                const timeRange = endTimeFormatted ? `${startTimeFormatted} - ${endTimeFormatted}` : startTimeFormatted;
                const durationStr = night.duration.toFixed(1) + 'h';
                const sessionsStr = night.sessions > 1 ? ` (${night.sessions} sessions)` : '';
                opt.textContent = `${night.date} | ${timeRange} | ${durationStr}${sessionsStr}`;
                select.appendChild(opt);
            });
            if (nightlyData.length > 0) {
                select.value = nightlyData[0].date; // most recent
            }
            // Enable/disable nav buttons
            updateNightNavButtons();
        }

        // Update heatmap when a different night is selected
        function updateNightHeatmap() {
            const select = document.getElementById('nightSelect');
            if (!select || !window.originalNightlyData) return;
            const date = select.value;
            const night = window.originalNightlyData.find(n => n.date === date);
            if (!night) return;
            updateNightNavButtons();

            // If session view is enabled, repopulate session selector
            const isSessionView = document.getElementById('heatmapSessionToggle')?.checked;
            if (isSessionView) {
                populateSessionSelector();
                return; // populateSessionSelector will call updateSessionHeatmap
            }

            // Build concatenated inspirations and render just like in most-recent function
            const sessions = getSessionsForNight(date);
            if (!sessions || sessions.length === 0) return;
            sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));
            let sampleOffset = 0;
            const concatenatedInspirations = [];
            sessions.forEach(session => {
                if (!session.inspirations) return;
                session.inspirations.forEach(insp => {
                    concatenatedInspirations.push({
                        start: (insp.start || 0) + sampleOffset,
                        end: (insp.end || 0) + sampleOffset,
                        indices: insp.indices
                    });
                });
                const sessionSamples = session.sampleCount || (session.inspirations[session.inspirations.length - 1]?.end || 0);
                sampleOffset += sessionSamples;
            });
            window.startDateTime = new Date(sessions[0].startDateTime);

            // Lazily build flow data only for sessions of this night
            sessions.forEach(session => ensureFlowData(session));

            // Build concatenated flow data for click-to-inspect
            const allFlowData = [];
            const allIdealData = [];
            sessions.forEach(session => {
                if (session.flowData && session.flowData.length > 0) {
                    for (let j = 0; j < session.flowData.length; j++) {
                        allFlowData.push(session.flowData[j]);
                    }
                    if (session.idealData) {
                        for (let j = 0; j < session.idealData.length; j++) {
                            allIdealData.push(session.idealData[j]);
                        }
                    }
                }
            });
            dataArray = allFlowData.length > 0 ? allFlowData : [];

            try {
                displayHeatMap({
                    inspirations: concatenatedInspirations,
                    cumIndex: night.weightedGI,
                    idealArray: allIdealData,
                    flowImbalance: []
                });
                // Show detail section on heatmap click
                const chartTopEl = document.getElementById('chartTop');
                if (chartTopEl) {
                    chartTopEl.addEventListener('click', function () {
                        setTimeout(function () {
                            if (chartDetail) {
                                showDetailSection();
                                document.getElementById('detailChartSection')?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }, 100);
                    }, false);
                }
            } catch (e) {
                console.error('Heatmap render failed:', e);
            }
        }

        // Night navigation helpers
        function prevNight() {
            const select = document.getElementById('nightSelect');
            if (!select) return;
            const idx = select.selectedIndex;
            if (idx < select.options.length - 1) {
                select.selectedIndex = idx + 1; // list is most-recent first
                updateNightHeatmap();
            }
        }

        function nextNight() {
            const select = document.getElementById('nightSelect');
            if (!select) return;
            const idx = select.selectedIndex;
            if (idx > 0) {
                select.selectedIndex = idx - 1;
                updateNightHeatmap();
            }
        }

        function updateNightNavButtons() {
            const select = document.getElementById('nightSelect');
            const prev = document.getElementById('nightPrev');
            const next = document.getElementById('nightNext');
            if (!select || !prev || !next) return;
            prev.disabled = (select.selectedIndex >= select.options.length - 1);
            next.disabled = (select.selectedIndex <= 0);
        }

        // Toggle between combined night view and individual session view for heatmap
        function toggleHeatmapSessionView() {
            const isSessionView = document.getElementById('heatmapSessionToggle').checked;
            const sessionBlock = document.getElementById('sessionSelectBlock');

            if (isSessionView) {
                // Populate session selector for current night
                populateSessionSelector();
                sessionBlock.style.display = '';
            } else {
                sessionBlock.style.display = 'none';
                // Refresh to show combined night view
                updateNightHeatmap();
            }
        }

        // Populate the session selector for the currently selected night
        function populateSessionSelector() {
            const nightSelect = document.getElementById('nightSelect');
            const sessionSelect = document.getElementById('sessionSelect');
            if (!nightSelect || !sessionSelect) return;

            const date = nightSelect.value;
            const sessions = getSessionsForNight(date);
            if (!sessions || sessions.length === 0) return;

            // Sort sessions by start time
            sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));

            sessionSelect.innerHTML = '';

            // Add "All Sessions Combined" option first
            const allOpt = document.createElement('option');
            allOpt.value = 'all';
            allOpt.textContent = 'All Sessions Combined';
            sessionSelect.appendChild(allOpt);

            // Add individual sessions
            sessions.forEach((session, index) => {
                const opt = document.createElement('option');
                opt.value = index.toString();
                const startTime = formatDateTimeAMPM(session.startDateTime);
                const endTime = session.endDateTime ? formatDateTimeAMPM(session.endDateTime) : '';
                const durationStr = session.duration.toFixed(1) + 'h';
                opt.textContent = `Session ${index + 1}: ${startTime}${endTime ? ' - ' + endTime : ''} (${durationStr})`;
                sessionSelect.appendChild(opt);
            });

            // Render the first selected option (All Combined)
            updateSessionHeatmap();
        }

        // Render heatmap for selected individual session or all combined
        function updateSessionHeatmap() {
            const nightSelect = document.getElementById('nightSelect');
            const sessionSelect = document.getElementById('sessionSelect');
            const isSessionView = document.getElementById('heatmapSessionToggle')?.checked;

            if (!nightSelect || !sessionSelect || !isSessionView) {
                updateNightHeatmap();
                return;
            }

            const date = nightSelect.value;
            const sessions = getSessionsForNight(date);
            if (!sessions || sessions.length === 0) return;

            sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));

            const selectedValue = sessionSelect.value;

            if (selectedValue === 'all') {
                // Show combined view
                updateNightHeatmap();
                return;
            }

            // Show individual session
            const sessionIndex = parseInt(selectedValue, 10);
            if (isNaN(sessionIndex) || sessionIndex < 0 || sessionIndex >= sessions.length) return;

            const session = sessions[sessionIndex];

            // Lazily build flow data for this session
            ensureFlowData(session);

            window.startDateTime = new Date(session.startDateTime);
            window.dataArray = new Float32Array(Math.max(session.sampleCount || 1, 1));

            // Calculate overall GI for this session
            const gi = session.cumIndex;
            const overallGI = gi.skew + gi.spike + gi.flatTop + gi.topHeavy +
                gi.multiPeak + gi.noPause + gi.inspirRate + gi.multiBreath + gi.ampVar;

            const cumIndexWithOverall = { ...gi, overall: Math.round(overallGI * 100) / 100 };

            try {
                displayHeatMap({ inspirations: session.inspirations || [], cumIndex: cumIndexWithOverall });
                // Show detail section on heatmap click
                const chartTopEl = document.getElementById('chartTop');
                if (chartTopEl) {
                    chartTopEl.addEventListener('click', function () {
                        setTimeout(function () {
                            if (chartDetail) {
                                showDetailSection();
                                document.getElementById('detailChartSection')?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }, 100);
                    }, false);
                }
            } catch (e) {
                console.error('Heatmap render failed:', e);
            }
        }

        function updateSummaryCards(nightlyData) {
            document.getElementById('nightsCount').textContent = nightlyData.length;

            if (nightlyData.length > 0) {
                const avgOverall = nightlyData.reduce((sum, night) => sum + night.weightedGI.overall, 0) / nightlyData.length;
                const bestNight = Math.min(...nightlyData.map(night => night.weightedGI.overall));
                const worstNight = Math.max(...nightlyData.map(night => night.weightedGI.overall));

                document.getElementById('avgOverallGI').textContent = avgOverall.toFixed(2);
                document.getElementById('bestNightGI').textContent = bestNight.toFixed(2);
                document.getElementById('worstNightGI').textContent = worstNight.toFixed(2);
            }
        }

        function createTrendsChart(nightlyData) {
            window.originalNightlyData = nightlyData; // Store for filtering
            // Small delay to ensure DOM is ready and prevent resize loops
            setTimeout(() => {
                // Initialize custom date inputs to full span if empty
                const block = document.getElementById('customDateBlock');
                const startInput = document.getElementById('customStartDate');
                const endInput = document.getElementById('customEndDate');
                if (nightlyData && nightlyData.length > 0 && startInput && endInput) {
                    const dates = nightlyData.map(n => new Date(n.date)).sort((a, b) => a - b);
                    const min = dates[0];
                    const max = dates[dates.length - 1];
                    if (!startInput.value) startInput.value = formatDateISO(min);
                    if (!endInput.value) endInput.value = formatDateISO(max);
                    startInput.max = formatDateISO(max);
                    endInput.min = formatDateISO(min);
                }
                updateTrendsChart();
            }, 100);
        }

        function updateAllCharts() {
            updateTrendsChart();
            updateComponentsChart();
        }

        function updateTrendsChart() {
            const ctx = document.getElementById('trendsChart').getContext('2d');

            if (trendsChart) {
                trendsChart.destroy();
            }

            // Get filter settings
            const dateRange = document.getElementById('dateRangeSelect').value;
            const smoothing = document.getElementById('smoothingSelect').value;

            // Filter data by date range
            let filteredData = filterByDateRange(window.originalNightlyData, dateRange);

            // Optionally hide nights with <4 hours duration
            const hideShort = document.getElementById('hideShortNights')?.checked;
            if (hideShort) {
                filteredData = filteredData.filter(n => (n.duration || 0) >= 4.0);
            }

            // Sort chronologically for proper trend visualization
            filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // Apply smoothing
            const smoothedData = applySmoothing(filteredData, smoothing);

            const labels = smoothedData.map(night => night.date);
            const overallData = smoothedData.map(night => night.weightedGI.overall);

            // Calculate trend line
            const trendLine = calculateLinearTrend(overallData);

            // Create datasets
            const datasets = [{
                label: 'Overall Glasgow Index',
                data: overallData,
                borderColor: '#007bff',
                backgroundColor: 'rgba(0, 123, 255, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.2,
                pointRadius: 5,
                pointHoverRadius: 8
            }];

            // Add trend line
            if (smoothedData.length > 2) {
                datasets.push({
                    label: 'Trend Line',
                    data: trendLine,
                    borderColor: '#dc3545',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    tension: 0
                });
            }

            // Calculate smart Y-axis scaling
            const maxGI = Math.max(...overallData);
            const minGI = Math.min(...overallData);
            const dataRange = maxGI - minGI;

            // Smart scaling based on data range
            let yMax;
            if (maxGI <= 0.5) {
                yMax = Math.ceil(maxGI * 10) / 10 + 0.1; // Round up to nearest 0.1 + buffer
            } else if (maxGI <= 1.0) {
                yMax = Math.ceil(maxGI * 4) / 4 + 0.25; // Round up to nearest 0.25 + buffer
            } else if (maxGI <= 2.0) {
                yMax = Math.ceil(maxGI * 2) / 2 + 0.5; // Round up to nearest 0.5 + buffer
            } else if (maxGI <= 4.0) {
                yMax = Math.ceil(maxGI) + 1; // Round up to nearest integer + buffer
            } else {
                yMax = Math.ceil(maxGI * 1.25); // 25% buffer for high values
            }

            // Ensure minimum range for visual clarity
            if (dataRange < 0.2 && maxGI < 2.0) {
                yMax = Math.max(yMax, maxGI + 0.3);
            }

            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    animation: {
                        duration: 0
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: yMax,
                            title: {
                                display: true,
                                text: 'Glasgow Index',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                callback: function (value) {
                                    // Dynamic precision based on range
                                    if (yMax <= 1.0) {
                                        return value.toFixed(2);
                                    } else if (yMax <= 3.0) {
                                        return value.toFixed(1);
                                    } else {
                                        return value.toFixed(0);
                                    }
                                },
                                stepSize: function () {
                                    // Dynamic step size based on range
                                    if (yMax <= 0.5) return 0.1;
                                    if (yMax <= 1.0) return 0.2;
                                    if (yMax <= 2.0) return 0.5;
                                    if (yMax <= 5.0) return 1.0;
                                    return 2.0;
                                }()
                            },
                            grid: {
                                color: function (context) {
                                    // Color-code quality zones
                                    const value = context.tick.value;
                                    if (value <= 0.2) return 'rgba(40, 167, 69, 0.2)'; // Excellent
                                    if (value <= 1.0) return 'rgba(23, 162, 184, 0.2)'; // Good
                                    if (value <= 2.0) return 'rgba(255, 193, 7, 0.2)'; // Fair
                                    if (value <= 3.0) return 'rgba(220, 53, 69, 0.2)'; // Poor
                                    return 'rgba(108, 117, 125, 0.2)'; // Very Poor
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                maxTicksLimit: 12,
                                callback: function (value, index) {
                                    const date = new Date(this.getLabelForValue(value));
                                    return date.toLocaleDateString('en-US', {
                                        month: 'short',
                                        day: 'numeric'
                                    });
                                }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Glasgow Index Trend ${getDateRangeTitle(dateRange)} ${getSmoothingTitle(smoothing)}`,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: function (context) {
                                    return `Night: ${context[0].label}`;
                                },
                                afterLabel: function (context) {
                                    const gi = context.parsed.y;
                                    let quality = 'Very Poor';
                                    if (gi <= 0.2) quality = 'Excellent';
                                    else if (gi <= 1.0) quality = 'Good';
                                    else if (gi <= 2.0) quality = 'Fair';
                                    else if (gi <= 3.0) quality = 'Poor';

                                    return `Quality: ${quality}`;
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }

        function createComponentsChart(nightlyData) {
            window.originalComponentData = nightlyData; // Store for filtering
            // Small delay to ensure DOM is ready and prevent resize loops
            setTimeout(() => {
                updateComponentsChart();
            }, 100);
        }

        function updateComponentsChart() {
            const ctx = document.getElementById('componentsChart').getContext('2d');

            if (componentsChart) {
                componentsChart.destroy();
            }

            // Get settings
            const showTrendLines = document.getElementById('showTrendLines').checked;

            // Apply same filtering as trends chart
            const dateRange = document.getElementById('dateRangeSelect').value;
            const smoothing = document.getElementById('smoothingSelect').value;

            // Filter data by date range
            let filteredData = filterByDateRange(window.originalComponentData, dateRange);

            // Optionally hide nights with <4 hours duration
            const hideShort = document.getElementById('hideShortNights')?.checked;
            if (hideShort) {
                filteredData = filteredData.filter(n => (n.duration || 0) >= 4.0);
            }

            // Sort chronologically for proper trend visualization
            filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // Apply smoothing
            const nightlyData = applySmoothing(filteredData, smoothing);
            const labels = nightlyData.map(night => night.date);
            const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#2ECC71', '#9966FF',
                '#FF9F40', '#8B4513', '#C9CBCF', '#000000'
            ];

            const datasets = [];

            components.forEach((component, index) => {
                // Check if this component is selected for display
                const compCheckbox = document.getElementById(`comp_${component}`);
                const isSelected = compCheckbox ? compCheckbox.checked : true; // Default to true if checkbox doesn't exist
                if (!isSelected) return;

                let data = nightlyData.map(night => night.weightedGI[component]);

                const dataset = {
                    label: formatComponentName(component),
                    data: data,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '30',
                    borderWidth: 2.5,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 4,
                    pointHoverRadius: 7,
                    pointBackgroundColor: colors[index],
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                };

                datasets.push(dataset);

                // Add trend lines if requested
                if (showTrendLines && data.length > 2) {
                    const trendData = calculateLinearTrend(data);
                    datasets.push({
                        label: `${formatComponentName(component)} Trend`,
                        data: trendData,
                        borderColor: colors[index],
                        backgroundColor: 'transparent',
                        borderWidth: 1.5,
                        borderDash: [3, 3],
                        fill: false,
                        pointRadius: 0,
                        tension: 0,
                        hidden: false // Show in legend but less prominent
                    });
                }
            });

            const yAxisTitle = 'Component Index Value';
            const yAxisMax = undefined;

            componentsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    animation: {
                        duration: 0
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: yAxisMax,
                            title: {
                                display: true,
                                text: yAxisTitle,
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                callback: function (value) {
                                    return value.toFixed(1);
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                maxTicksLimit: 12,
                                callback: function (value, index) {
                                    const date = new Date(this.getLabelForValue(value));
                                    return date.toLocaleDateString('en-US', {
                                        month: 'short',
                                        day: 'numeric'
                                    });
                                }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Glasgow Index Components Over Time ${getDateRangeTitle(dateRange)} ${getSmoothingTitle(smoothing)}`,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'right',
                            labels: {
                                filter: function (legendItem, chartData) {
                                    // Hide trend line entries from legend for cleaner display
                                    return !legendItem.text.includes('Trend');
                                },
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function (context) {
                                    return `Night: ${context[0].label}`;
                                },
                                label: function (context) {
                                    const value = context.parsed.y.toFixed(2);
                                    return `${context.dataset.label}: ${value}`;
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }

        function createResultsTable(nightlyData) {
            const tbody = document.getElementById('resultsTableBody');
            const titleEl = document.getElementById('resultsTableTitle');
            tbody.innerHTML = '';

            if (showSessionView) {
                // Session-by-session view
                titleEl.textContent = 'Individual Session Results';
                renderSessionTable(tbody);
            } else {
                // Night-by-night aggregated view
                titleEl.textContent = 'Detailed Night-by-Night Results';
                renderNightlyTable(tbody, nightlyData);
            }
        }

        function renderNightlyTable(tbody, nightlyData) {
            // Calculate min/max for each GI component to establish the gradient range
            const components = ['overall', 'skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
            const wobbleComponents = ['composite', 'flScore', 'regularityScore', 'periodicityIndex', 'eai'];
            const stats = {};

            components.forEach(comp => {
                let values;
                if (comp === 'overall') {
                    values = nightlyData.map(n => n.weightedGI.overall);
                } else {
                    values = nightlyData.map(n => n.weightedGI[comp]);
                }
                stats[comp] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            });

            wobbleComponents.forEach(comp => {
                const values = nightlyData
                    .map(n => n._wobbleAvg?.[comp])
                    .filter(v => v !== undefined && v !== null && !isNaN(v));
                if (values.length > 0) {
                    stats['wobble_' + comp] = {
                        min: Math.min(...values),
                        max: Math.max(...values)
                    };
                }
            });

            // Helper to get background style
            const getBgStyle = (comp, value) => {
                const range = stats[comp];
                if (!range) return '';
                const color = getGradientColor(value, range.min, range.max);
                return `background-color: ${color}; color: #000;`;
            };

            // Helper for wobble gradient (higher = worse, except regularityScore where higher = better)
            const getWobbleBgStyle = (comp, value) => {
                if (value === undefined || value === null || isNaN(value)) return 'background:#f5f0ff;';
                const key = 'wobble_' + comp;
                const range = stats[key];
                if (!range) return 'background:#f5f0ff;';
                if (comp === 'regularityScore') {
                    // Higher regularity = better, so invert: green for high, red for low
                    const color = getGradientColor(value, range.max, range.min);
                    return `background-color: ${color}; color: #000;`;
                }
                const color = getGradientColor(value, range.min, range.max);
                return `background-color: ${color}; color: #000;`;
            };

            nightlyData.forEach((night, nightIdx) => {
                const allSessions = night._allSessions || [];
                const hasMultiple = allSessions.length > 1;
                const nightId = `night-${nightIdx}`;

                // --- Main night summary row ---
                const row = document.createElement('tr');
                row.id = nightId;
                if (hasMultiple) row.classList.add('night-row-expandable');
                row.onclick = hasMultiple ? () => toggleSubSessions(nightIdx) : null;

                const expandIcon = hasMultiple ? `<span class="expand-toggle" id="expand-${nightIdx}">&#9654;</span>` : '';
                const sessionPill = hasMultiple ? `<span class="session-count-pill">${allSessions.length} sessions</span>` : '';

                row.innerHTML = `
    <td>${expandIcon}${night.date}${sessionPill}</td>
    <td>${night.startTime || 'Unknown'}</td>
    <td>${night.endTime || 'N/A'}</td>
    <td>${night.duration.toFixed(1)}</td>
    <td>${night.machineType}</td>
    <td>${night.papMode || 'Unknown'}</td>
    <td style="${getBgStyle('overall', night.weightedGI.overall)}"><b>${night.weightedGI.overall.toFixed(2)}</b></td>
    <td style="${getBgStyle('skew', night.weightedGI.skew)}">${night.weightedGI.skew.toFixed(2)}</td>
    <td style="${getBgStyle('spike', night.weightedGI.spike)}">${night.weightedGI.spike.toFixed(2)}</td>
    <td style="${getBgStyle('flatTop', night.weightedGI.flatTop)}">${night.weightedGI.flatTop.toFixed(2)}</td>
    <td style="${getBgStyle('topHeavy', night.weightedGI.topHeavy)}">${night.weightedGI.topHeavy.toFixed(2)}</td>
    <td style="${getBgStyle('multiPeak', night.weightedGI.multiPeak)}">${night.weightedGI.multiPeak.toFixed(2)}</td>
    <td style="${getBgStyle('noPause', night.weightedGI.noPause)}">${night.weightedGI.noPause.toFixed(2)}</td>
    <td style="${getBgStyle('inspirRate', night.weightedGI.inspirRate)}">${night.weightedGI.inspirRate.toFixed(2)}</td>
    <td style="${getBgStyle('multiBreath', night.weightedGI.multiBreath)}">${night.weightedGI.multiBreath.toFixed(2)}</td>
    <td style="${getBgStyle('ampVar', night.weightedGI.ampVar)}">${night.weightedGI.ampVar.toFixed(2)}</td>
    <td style="${getWobbleBgStyle('composite', night._wobbleAvg?.composite)}; font-weight:bold;">${fmtWobble(night._wobbleAvg?.composite, 1)}</td>
    <td style="${getWobbleBgStyle('flScore', night._wobbleAvg?.flScore)}">${fmtWobble(night._wobbleAvg?.flScore, 1)}</td>
    <td style="${getWobbleBgStyle('regularityScore', night._wobbleAvg?.regularityScore)}">${fmtWobble(night._wobbleAvg?.regularityScore, 1)}</td>
    <td style="${getWobbleBgStyle('periodicityIndex', night._wobbleAvg?.periodicityIndex)}">${fmtWobble(night._wobbleAvg?.periodicityIndex, 1)}</td>
    <td style="${getWobbleBgStyle('eai', night._wobbleAvg?.eai)}">${fmtWobble(night._wobbleAvg?.eai, 1)}</td>
    <td class="cpap-col">${night.ipap !== 'N/A' ? night.ipap : 'N/A'}</td>
    <td class="cpap-col">${night.minIPAP !== 'N/A' ? night.minIPAP : 'N/A'}</td>
    <td class="cpap-col">${night.maxIPAP !== 'N/A' ? night.maxIPAP : 'N/A'}</td>
    <td class="cpap-col">${night.epap !== 'N/A' ? night.epap : 'N/A'}</td>
    <td class="cpap-col">${night.minEPAP !== 'N/A' ? night.minEPAP : 'N/A'}</td>
    <td class="cpap-col">${night.maxEPAP !== 'N/A' ? night.maxEPAP : 'N/A'}</td>
    <td class="cpap-col">${night.pressureSupport !== 'N/A' ? night.pressureSupport : 'N/A'}</td>
    <td class="cpap-col">${night.easyBreathe !== 'N/A' && !night.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? night.easyBreathe : 'N/A'}</td>
    <td class="cpap-col">${night.riseTime !== 'N/A' && !night.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? night.riseTime : 'N/A'}</td>
    <td class="cpap-col">${night.trigger !== 'N/A' && !night.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? sensitivityLabelFromValue(night.trigger) : 'N/A'}</td>
    <td class="cpap-col">${night.cycle !== 'N/A' && !night.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? sensitivityLabelFromValue(night.cycle) : 'N/A'}</td>
    <td>-</td>
    <td>-</td>
`;

                tbody.appendChild(row);

                // --- Sub-session rows (hidden by default) ---
                if (hasMultiple) {
                    allSessions.forEach((session, sessIdx) => {
                        const subRow = document.createElement('tr');
                        subRow.classList.add('sub-session-row', `sub-${nightIdx}`);
                        if (!session._includedInDay) subRow.classList.add('excluded');
                        subRow.style.display = 'none'; // Hidden by default

                        const badge = getSessionTypeBadge(session._sessionType);
                        const gi = session.cumIndex;
                        const overallGI = gi.skew + gi.spike + gi.flatTop + gi.topHeavy + gi.multiPeak + gi.noPause + gi.inspirRate + gi.multiBreath + gi.ampVar;
                        const endTime = session.endDateTime ? formatDateTimeAMPM(session.endDateTime) : 'N/A';

                        let pressureSupport = 'N/A';
                        if (session.ipap !== 'N/A' && session.epap !== 'N/A') {
                            pressureSupport = Math.round((parseFloat(session.ipap) - parseFloat(session.epap)) * 10) / 10;
                        }

                        // Extract just the filename from the path
                        const shortFileName = session.fileName ? session.fileName.replace(/^.*[\\\/]/, '') : '';

                        subRow.innerHTML = `
    <td>
        <input type="checkbox" class="include-cb" ${session._includedInDay ? 'checked' : ''}
            onclick="event.stopPropagation(); onSessionInclusionChange(${nightIdx}, ${sessIdx}, this.checked)"
            title="${session._includedInDay ? 'Included in day total' : 'Excluded from day total'}">
        <span class="session-type-badge ${badge.cssClass}">${badge.emoji} ${badge.label}</span>
        <br><span style="font-size:10px; color:#888;" title="${escapeHtml(session.fileName || '')}">${escapeHtml(shortFileName)}</span>
    </td>
    <td>${formatTimeAMPM(session.time)}</td>
    <td>${endTime}</td>
    <td>${session.duration.toFixed(1)}</td>
    <td>${session.machineType || 'Unknown'}</td>
    <td>${session.papMode || 'Unknown'}</td>
    <td style="${getBgStyle('overall', overallGI)}"><b>${overallGI.toFixed(2)}</b></td>
    <td style="${getBgStyle('skew', gi.skew)}">${gi.skew.toFixed(2)}</td>
    <td style="${getBgStyle('spike', gi.spike)}">${gi.spike.toFixed(2)}</td>
    <td style="${getBgStyle('flatTop', gi.flatTop)}">${gi.flatTop.toFixed(2)}</td>
    <td style="${getBgStyle('topHeavy', gi.topHeavy)}">${gi.topHeavy.toFixed(2)}</td>
    <td style="${getBgStyle('multiPeak', gi.multiPeak)}">${gi.multiPeak.toFixed(2)}</td>
    <td style="${getBgStyle('noPause', gi.noPause)}">${gi.noPause.toFixed(2)}</td>
    <td style="${getBgStyle('inspirRate', gi.inspirRate)}">${gi.inspirRate.toFixed(2)}</td>
    <td style="${getBgStyle('multiBreath', gi.multiBreath)}">${gi.multiBreath.toFixed(2)}</td>
    <td style="${getBgStyle('ampVar', gi.ampVar)}">${gi.ampVar.toFixed(2)}</td>
    <td style="${getWobbleBgStyle('composite', session.wobble?.composite)}; font-weight:bold;">${fmtWobble(session.wobble?.composite, 1)}</td>
    <td style="${getWobbleBgStyle('flScore', session.wobble?.flScore)}">${fmtWobble(session.wobble?.flScore, 1)}</td>
    <td style="${getWobbleBgStyle('regularityScore', session.wobble?.regularityScore)}">${fmtWobble(session.wobble?.regularityScore, 1)}</td>
    <td style="${getWobbleBgStyle('periodicityIndex', session.wobble?.periodicityIndex)}">${fmtWobble(session.wobble?.periodicityIndex, 1)}</td>
    <td style="${getWobbleBgStyle('eai', session.wobble?.eai)}">${fmtWobble(session.wobble?.eai, 1)}</td>
    <td class="cpap-col">${session.ipap !== 'N/A' ? session.ipap : 'N/A'}</td>
    <td class="cpap-col">${session.minIPAP !== 'N/A' ? session.minIPAP : '-'}</td>
    <td class="cpap-col">${session.maxIPAP !== 'N/A' ? session.maxIPAP : '-'}</td>
    <td class="cpap-col">${session.epap !== 'N/A' ? session.epap : 'N/A'}</td>
    <td class="cpap-col">${session.minEPAP !== 'N/A' ? session.minEPAP : '-'}</td>
    <td class="cpap-col">${session.maxEPAP !== 'N/A' ? session.maxEPAP : '-'}</td>
    <td class="cpap-col">${session.ps !== 'N/A' && session.ps !== undefined ? session.ps : pressureSupport}</td>
    <td class="cpap-col">${session.easyBreathe !== 'N/A' && !session.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? session.easyBreathe : 'N/A'}</td>
    <td class="cpap-col">${session.riseTime !== 'N/A' && !session.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? session.riseTime : 'N/A'}</td>
    <td class="cpap-col">${session.trigger !== 'N/A' && !session.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? sensitivityLabelFromValue(session.trigger) : 'N/A'}</td>
    <td class="cpap-col">${session.cycle !== 'N/A' && !session.papMode.toLowerCase().match(/asv|autoset|cpap/i) ? sensitivityLabelFromValue(session.cycle) : 'N/A'}</td>
    <td>-</td>
    <td>-</td>
`;
                        tbody.appendChild(subRow);
                    });
                }
            });
        }

        /**
         * Toggle sub-session rows visibility for a given night index.
         */
        function toggleSubSessions(nightIdx) {
            const subRows = document.querySelectorAll(`.sub-${nightIdx}`);
            const expandIcon = document.getElementById(`expand-${nightIdx}`);
            const isExpanded = subRows.length > 0 && subRows[0].style.display !== 'none';

            subRows.forEach(row => {
                row.style.display = isExpanded ? 'none' : '';
            });
            if (expandIcon) {
                expandIcon.textContent = isExpanded ? '\u25B6' : '\u25BC';
            }
        }

        /**
         * Handle include/exclude checkbox change for a sub-session.
         * Recalculates the night's aggregates and updates the summary row inline.
         */
        function onSessionInclusionChange(nightIdx, sessIdx, included) {
            if (!window.originalNightlyData) return;
            const night = window.originalNightlyData[nightIdx];
            if (!night || !night._allSessions) return;

            const session = night._allSessions[sessIdx];
            if (!session) return;

            // Update state
            session._includedInDay = included;
            saveSessionInclusion(session.fileName, included);

            // Recalculate the night aggregate
            const updated = recalculateNightFromSessions(night.date, night._allSessions);

            // Copy updated values back to the night object in originalNightlyData
            Object.assign(night, updated);

            // Update the sub-session row styling
            const subRow = document.querySelectorAll(`.sub-${nightIdx}`)[sessIdx];
            if (subRow) {
                if (included) {
                    subRow.classList.remove('excluded');
                } else {
                    subRow.classList.add('excluded');
                }
            }

            // Update only the summary row for this night (avoid full table re-render which collapses sessions)
            const summaryRow = document.getElementById(`night-${nightIdx}`);
            if (summaryRow) {
                const gi = night.weightedGI || night.cumIndex || {};
                const giKeys = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
                const cells = summaryRow.querySelectorAll('td');
                // Update overall GI cell (the one after the date/sessions info)
                // The table structure has: Date, Sessions, then 9 GI components, then Overall, then 3 Wobble, then pressure cols
                if (cells.length > 2) {
                    // Update GI component cells (indices 2-10 in the row)
                    giKeys.forEach((key, i) => {
                        const cellIdx = i + 2;
                        if (cells[cellIdx]) {
                            const val = gi[key] !== undefined ? gi[key] : 'N/A';
                            cells[cellIdx].textContent = typeof val === 'number' ? val.toFixed(2) : val;
                        }
                    });
                    // Update overall cell (index 11)
                    if (cells[11]) cells[11].textContent = gi.overall !== undefined ? gi.overall.toFixed(2) : 'N/A';
                }
            }

            // Update charts (lightweight, doesn't re-render table)
            updateAllCharts();
        }

        function renderSessionTable(tbody) {
            // Sort sessions by start time, most recent first
            let sortedSessions = [...nightlyResults].sort((a, b) =>
                new Date(b.startDateTime) - new Date(a.startDateTime)
            );

            // Filter out sessions < 20 minutes if checkbox is checked
            const hideShort = document.getElementById('hideShortSessions')?.checked;
            if (hideShort) {
                sortedSessions = sortedSessions.filter(s => s.duration >= (20 / 60) || s._sessionType === 'noon-split'); // keep continuations
            }

            // Filter out deleted sessions
            const deletedSessions = getDeletedSessions();
            sortedSessions = sortedSessions.filter(s => !deletedSessions.includes(s.fileName));

            // Calculate min/max for each GI component for sessions
            const components = ['overall', 'skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
            const wobbleComponents = ['composite', 'flScore', 'regularityScore', 'periodicityIndex', 'eai'];
            const stats = {};

            // Helper to extract component value from session
            const getCompValue = (s, comp) => {
                if (comp === 'overall') {
                    const gi = s.cumIndex;
                    return gi.skew + gi.spike + gi.flatTop + gi.topHeavy + gi.multiPeak + gi.noPause + gi.inspirRate + gi.multiBreath + gi.ampVar;
                }
                return s.cumIndex[comp];
            };

            components.forEach(comp => {
                const values = sortedSessions.map(s => getCompValue(s, comp));
                stats[comp] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            });

            wobbleComponents.forEach(comp => {
                const values = sortedSessions
                    .map(s => s.wobble?.[comp])
                    .filter(v => v !== undefined && v !== null && !isNaN(v));
                if (values.length > 0) {
                    stats['wobble_' + comp] = {
                        min: Math.min(...values),
                        max: Math.max(...values)
                    };
                }
            });

            sortedSessions.forEach(session => {
                const row = document.createElement('tr');
                row.dataset.filename = session.fileName;
                const gi = session.cumIndex;
                const overallGI = getCompValue(session, 'overall');

                // Calculate end time
                const endTime = session.endDateTime ? formatDateTimeAMPM(session.endDateTime) : 'N/A';

                // Calculate pressure support for session
                let pressureSupport = 'N/A';
                if (session.ipap !== 'N/A' && session.epap !== 'N/A') {
                    pressureSupport = Math.round((parseFloat(session.ipap) - parseFloat(session.epap)) * 10) / 10;
                }

                // Get stored notes for this session
                const notes = getSessionNotes(session.fileName);

                // Helper to get background style
                const getBgStyle = (comp, value) => {
                    const range = stats[comp];
                    if (!range) return '';
                    const color = getGradientColor(value, range.min, range.max);
                    return `background-color: ${color}; color: #000;`;
                };

                // Helper for wobble gradient
                const getWobbleBgStyle = (comp, value) => {
                    if (value === undefined || value === null || isNaN(value)) return 'background:#f5f0ff;';
                    const key = 'wobble_' + comp;
                    const range = stats[key];
                    if (!range) return 'background:#f5f0ff;';
                    if (comp === 'regularityScore') {
                        const color = getGradientColor(value, range.max, range.min);
                        return `background-color: ${color}; color: #000;`;
                    }
                    const color = getGradientColor(value, range.min, range.max);
                    return `background-color: ${color}; color: #000;`;
                };

                row.innerHTML = `
            <td>${session.date}</td>
            <td>${formatTimeAMPM(session.time)}</td>
            <td>${endTime}</td>
            <td>${session.duration.toFixed(1)}</td>
            <td>${session.machineType || 'Unknown'}</td>
            <td>${session.papMode || 'Unknown'}</td>
            <td style="${getBgStyle('overall', overallGI)}"><b>${overallGI.toFixed(2)}</b></td>
            <td style="${getBgStyle('skew', gi.skew)}">${gi.skew.toFixed(2)}</td>
            <td style="${getBgStyle('spike', gi.spike)}">${gi.spike.toFixed(2)}</td>
            <td style="${getBgStyle('flatTop', gi.flatTop)}">${gi.flatTop.toFixed(2)}</td>
            <td style="${getBgStyle('topHeavy', gi.topHeavy)}">${gi.topHeavy.toFixed(2)}</td>
            <td style="${getBgStyle('multiPeak', gi.multiPeak)}">${gi.multiPeak.toFixed(2)}</td>
            <td style="${getBgStyle('noPause', gi.noPause)}">${gi.noPause.toFixed(2)}</td>
            <td style="${getBgStyle('inspirRate', gi.inspirRate)}">${gi.inspirRate.toFixed(2)}</td>
            <td style="${getBgStyle('multiBreath', gi.multiBreath)}">${gi.multiBreath.toFixed(2)}</td>
            <td style="${getBgStyle('ampVar', gi.ampVar)}">${gi.ampVar.toFixed(2)}</td>
            <td style="${getWobbleBgStyle('composite', session.wobble?.composite)}; font-weight:bold;">${fmtWobble(session.wobble?.composite, 1)}</td>
            <td style="${getWobbleBgStyle('flScore', session.wobble?.flScore)}">${fmtWobble(session.wobble?.flScore, 1)}</td>
            <td style="${getWobbleBgStyle('regularityScore', session.wobble?.regularityScore)}">${fmtWobble(session.wobble?.regularityScore, 1)}</td>
            <td style="${getWobbleBgStyle('periodicityIndex', session.wobble?.periodicityIndex)}">${fmtWobble(session.wobble?.periodicityIndex, 1)}</td>
            <td style="${getWobbleBgStyle('eai', session.wobble?.eai)}">${fmtWobble(session.wobble?.eai, 1)}</td>
            <td class="cpap-col">${session.ipap !== 'N/A' ? session.ipap : 'N/A'}</td>
            <td class="cpap-col">-</td>
            <td class="cpap-col">-</td>
            <td class="cpap-col">${session.epap !== 'N/A' ? session.epap : 'N/A'}</td>
            <td class="cpap-col">-</td>
            <td class="cpap-col">-</td>
            <td class="cpap-col">${pressureSupport}</td>
            <td class="cpap-col">${session.easyBreathe !== 'N/A' ? session.easyBreathe : 'N/A'}</td>
            <td class="cpap-col">${session.riseTime !== 'N/A' ? session.riseTime : 'N/A'}</td>
            <td class="cpap-col">${session.trigger !== 'N/A' ? sensitivityLabelFromValue(session.trigger) : 'N/A'}</td>
            <td class="cpap-col">${session.cycle !== 'N/A' ? sensitivityLabelFromValue(session.cycle) : 'N/A'}</td>
            <td><input type="text" class="session-notes-input" value="${escapeHtml(notes)}" placeholder="Add notes..." onchange="saveSessionNotes('${escapeHtml(session.fileName)}', this.value)" style="width: 120px; padding: 2px 4px; font-size: 12px;"></td>
            <td><button onclick="deleteSession('${escapeHtml(session.fileName)}')" style="background: #dc3545; color: white; border: none; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;" title="Delete session">‚úï</button></td>
        `;

                tbody.appendChild(row);
            });
        }

        function getGradientColor(value, min, max) {
            if (min === max) return '#ffffff'; // Default to white if no variance

            // Normalize value between 0 and 1
            let ratio = (value - min) / (max - min);
            if (ratio < 0) ratio = 0;
            if (ratio > 1) ratio = 1;

            // 3-point gradient: Green (low) -> Yellow (mid) -> Red (high)
            // Low scores are GOOD (Green), High scores are BAD (Red)

            let r, g, b;

            if (ratio < 0.5) {
                // Green to Yellow
                // Green: (144, 238, 144) -> #90EE90 (LightGreen)
                // Yellow: (255, 255, 100)

                // Normalize ratio to 0-1 for this half
                const subRatio = ratio * 2;

                r = Math.round(144 + (255 - 144) * subRatio);
                g = Math.round(238 + (255 - 238) * subRatio); // slightly moves towards 255
                b = Math.round(144 + (100 - 144) * subRatio);
            } else {
                // Yellow to Red
                // Yellow: (255, 255, 100)
                // Red: (255, 99, 71) -> #FF6347 (Tomato)

                // Normalize ratio to 0-1 for this half
                const subRatio = (ratio - 0.5) * 2;

                r = 255;
                g = Math.round(255 + (99 - 255) * subRatio);
                b = Math.round(100 + (71 - 100) * subRatio);
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function toggleSessionView() {
            showSessionView = document.getElementById('sessionViewToggle').checked;
            // Show/hide the "Hide <20 min sessions" checkbox based on session view
            const hideShortLabel = document.getElementById('hideShortSessionsLabel');
            if (hideShortLabel) {
                hideShortLabel.style.display = showSessionView ? '' : 'none';
            }
            if (window.originalNightlyData) {
                createResultsTable(window.originalNightlyData);
            }
        }

        function toggleCpapColumns() {
            const show = document.getElementById('showCpapSettings').checked;
            document.querySelectorAll('.cpap-col').forEach(el => {
                el.style.display = show ? '' : 'none';
            });
            // Persist preference
            try { localStorage.setItem('megascore_showCpap', show ? '1' : '0'); } catch (e) { }
        }

        // Restore CPAP column preference on page load
        (function () {
            try {
                if (localStorage.getItem('megascore_showCpap') === '1') {
                    const cb = document.getElementById('showCpapSettings');
                    if (cb) { cb.checked = true; toggleCpapColumns(); }
                }
            } catch (e) { }
        })();

        // ============ Session Notes & Delete (localStorage) ============

        const STORAGE_KEY_NOTES = 'glasgowIndex_sessionNotes';
        const STORAGE_KEY_DELETED = 'glasgowIndex_deletedSessions';

        function getSessionNotes(fileName) {
            try {
                const notes = JSON.parse(localStorage.getItem(STORAGE_KEY_NOTES) || '{}');
                return notes[fileName] || '';
            } catch (e) {
                return '';
            }
        }

        function saveSessionNotes(fileName, note) {
            try {
                const notes = JSON.parse(localStorage.getItem(STORAGE_KEY_NOTES) || '{}');
                if (note && note.trim()) {
                    notes[fileName] = note.trim();
                } else {
                    delete notes[fileName];
                }
                localStorage.setItem(STORAGE_KEY_NOTES, JSON.stringify(notes));
            } catch (e) {
                console.error('Failed to save session notes:', e);
            }
        }

        function getDeletedSessions() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY_DELETED) || '[]');
            } catch (e) {
                return [];
            }
        }

        function deleteSession(fileName) {
            if (!confirm('Delete this session from view? (Can be restored by clearing browser data)')) {
                return;
            }
            try {
                const deleted = getDeletedSessions();
                if (!deleted.includes(fileName)) {
                    deleted.push(fileName);
                    localStorage.setItem(STORAGE_KEY_DELETED, JSON.stringify(deleted));
                }
                // Refresh the table
                if (window.originalNightlyData) {
                    createResultsTable(window.originalNightlyData);
                }
            } catch (e) {
                console.error('Failed to delete session:', e);
            }
        }

        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function formatComponentName(component) {
            const names = {
                skew: 'Skew',
                spike: 'Spike',
                flatTop: 'Flat Top',
                topHeavy: 'Top Heavy',
                multiPeak: 'Multi Peak',
                noPause: 'No Pause',
                inspirRate: 'Inspir Rate',
                multiBreath: 'Multi Breath',
                ampVar: 'Variable Amp'
            };
            return names[component] || component;
        }

        function getGIClass(value) {
            if (value <= 0.2) return 'gi-excellent';
            if (value <= 1.0) return 'gi-good';
            if (value <= 2.0) return 'gi-fair';
            if (value <= 3.0) return 'gi-poor';
            return 'gi-very-poor';
        }

        // Utility functions for enhanced charting

        function filterByDateRange(data, range) {
            if (range === 'all') return data;
            if (range === 'custom') {
                const s = document.getElementById('customStartDate')?.value;
                const e = document.getElementById('customEndDate')?.value;
                if (!s || !e) return data;
                const start = new Date(s);
                const end = new Date(e);
                // Include entire end day
                end.setHours(23, 59, 59, 999);
                return data.filter(night => new Date(night.date) >= start && new Date(night.date) <= end);
            }

            const days = parseInt(range);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - days);

            return data.filter(night => new Date(night.date) >= cutoffDate);
        }

        function applySmoothing(data, smoothing) {
            if (smoothing === 'none' || data.length < 3) return data;

            const window = parseInt(smoothing);
            const smoothedData = [];

            for (let i = 0; i < data.length; i++) {
                const start = Math.max(0, i - Math.floor(window / 2));
                const end = Math.min(data.length, i + Math.ceil(window / 2));

                const windowData = data.slice(start, end);
                const avgGI = {};

                // Calculate average for each component
                Object.keys(data[0].weightedGI).forEach(component => {
                    avgGI[component] = windowData.reduce((sum, night) =>
                        sum + night.weightedGI[component], 0) / windowData.length;
                    avgGI[component] = Math.round(avgGI[component] * 100) / 100;
                });

                smoothedData.push({
                    ...data[i],
                    weightedGI: avgGI
                });
            }

            return smoothedData;
        }

        function calculateLinearTrend(data) {
            if (data.length < 2) return data;

            const n = data.length;
            const x = Array.from({ length: n }, (_, i) => i);
            const y = data;

            // Calculate linear regression
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            return x.map(xi => slope * xi + intercept);
        }

        function filterOutliers(data) {
            if (data.length < 4) return data;

            // Calculate Q1, Q3, and IQR
            const sorted = [...data].sort((a, b) => a - b);
            const q1Index = Math.floor(sorted.length * 0.25);
            const q3Index = Math.floor(sorted.length * 0.75);
            const q1 = sorted[q1Index];
            const q3 = sorted[q3Index];
            const iqr = q3 - q1;

            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;

            // Replace outliers with median
            const median = sorted[Math.floor(sorted.length / 2)];

            return data.map(value => {
                if (value < lowerBound || value > upperBound) {
                    return median;
                }
                return value;
            });
        }

        function getDateRangeTitle(range) {
            if (range === 'custom') {
                const s = document.getElementById('customStartDate')?.value;
                const e = document.getElementById('customEndDate')?.value;
                if (s && e) {
                    return `(Custom: ${formatDateLabel(new Date(s))} to ${formatDateLabel(new Date(e))})`;
                }
                return '(Custom)';
            }
            switch (range) {
                case '30': return '(Last 30 Days)';
                case '60': return '(Last 60 Days)';
                case '90': return '(Last 90 Days)';
                default: return '';
            }
        }

        function getSmoothingTitle(smoothing) {
            switch (smoothing) {
                case '3': return '- 3-day Moving Average';
                case '7': return '- 7-day Moving Average';
                case '14': return '- 14-day Moving Average';
                default: return '';
            }
        }

        // Helpers for custom date handling
        function formatDateISO(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        function formatDateLabel(d) {
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function onDateRangeChange() {
            const range = document.getElementById('dateRangeSelect').value;
            const block = document.getElementById('customDateBlock');
            if (range === 'custom') {
                block.style.display = '';
            } else {
                block.style.display = 'none';
            }
        }

        // Component filtering functions

        function selectAllComponents() {
            const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
            components.forEach(comp => {
                const checkbox = document.getElementById(`comp_${comp}`);
                if (checkbox) checkbox.checked = true;
            });
            updateComponentsChart();
        }

        function selectNoComponents() {
            const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
            components.forEach(comp => {
                const checkbox = document.getElementById(`comp_${comp}`);
                if (checkbox) checkbox.checked = false;
            });
            updateComponentsChart();
        }

        function selectMainComponents() {
            // First uncheck all
            selectNoComponents();

            // Get filtered data to calculate averages
            const dateRange = document.getElementById('dateRangeSelect').value;
            let filteredData = filterByDateRange(window.originalComponentData, dateRange);

            if (filteredData.length === 0) return;

            // Calculate average values for each component over the filtered period
            const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
            const componentAverages = [];

            components.forEach(comp => {
                const avgValue = filteredData.reduce((sum, night) => sum + night.weightedGI[comp], 0) / filteredData.length;
                componentAverages.push({ component: comp, average: avgValue });
            });

            // Sort by average value (highest first) and take top 4
            componentAverages.sort((a, b) => b.average - a.average);
            const topComponents = componentAverages.slice(0, 4).map(item => item.component);

            // Select the top 4 components
            topComponents.forEach(comp => {
                const checkbox = document.getElementById(`comp_${comp}`);
                if (checkbox) checkbox.checked = true;
            });

            updateComponentsChart();
        }

        function selectFlowComponents() {
            // First uncheck all
            selectNoComponents();

            // Select components related to inspiration flow shape
            const flowComponents = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak'];
            flowComponents.forEach(comp => {
                const checkbox = document.getElementById(`comp_${comp}`);
                if (checkbox) checkbox.checked = true;
            });
            updateComponentsChart();
        }

        function selectTimingComponents() {
            // First uncheck all
            selectNoComponents();

            // Select components related to breathing timing and rhythm
            const timingComponents = ['noPause', 'inspirRate', 'multiBreath', 'ampVar'];
            timingComponents.forEach(comp => {
                const checkbox = document.getElementById(`comp_${comp}`);
                if (checkbox) checkbox.checked = true;
            });
            updateComponentsChart();
        }

        // STR file parsing for pressure settings
        async function parseSTRFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = function (event) {
                    try {
                        const arrayBuffer = event.target.result;
                        const fileData = parseEDFFile(arrayBuffer);

                        if (fileData.formatVersion !== "0") {
                            throw new Error("Incorrect STR file format");
                        }

                        // Extract pressure and mode data from STR file
                        const pressureData = extractPressureFromSTR(fileData);
                        resolve(pressureData);
                    } catch (error) {
                        reject(new Error(`Failed to parse STR file: ${error.message}`));
                    }
                };

                reader.onerror = function () {
                    reject(new Error(`Failed to read STR file ${file.name}`));
                };

                reader.readAsArrayBuffer(file);
            });
        }

        function extractPressureFromSTR(fileData) {
            // Extract pressure, mode, and key machine settings from STR file signals
            const pressureData = {
                dailyData: {},  // Date -> {ipap, epap, mode, riseTime, trigger, cycle, easyBreathe}
                defaultMode: 'Unknown',
                numSignals: 0  // Track signal count for firmware-dependent mode mapping
            };

            if (!fileData.signals) {
                console.log('No signals found in STR file');
                return pressureData;
            }

            // Store signal count - used to determine pre vs post AirBreak firmware
            pressureData.numSignals = fileData.signals.length;
            console.log(`STR file has ${pressureData.numSignals} signals (<=85 = pre-AirBreak, >85 = post-AirBreak)`);

            // Use the file start date as a reference point for date conversion
            const fileStartDate = fileData.startDateTime;
            console.log('STR file start date:', fileStartDate);

            console.log('=== STR File Signal Analysis ===');
            fileData.signals.forEach((signal, index) => {
                console.log(`Signal ${index}: "${signal.label}" (${signal.physDimension}) - ${signal.physicalValues ? signal.physicalValues.length : 0} samples`);
            });

            // Find key signals for pressure, mode, and additional settings
            const targetIPAPSignal = fileData.signals.find(s => s.label && s.label.includes('TgtIPAP.50'));
            const targetEPAPSignal = fileData.signals.find(s => s.label && s.label.includes('TgtEPAP.50'));
            const modeSignal = fileData.signals.find(s => s.label && s.label.includes('Mode'));
            const dateSignal = fileData.signals.find(s => s.label && s.label.includes('Date'));
            // Additional BiPAP settings
            const riseTimeSignal = fileData.signals.find(s => s.label && s.label.includes('S.RiseTime'));
            const triggerSignal = fileData.signals.find(s => s.label && s.label.includes('S.Trigger'));
            const cycleSignal = fileData.signals.find(s => s.label && s.label.includes('S.Cycle'));
            const easyBreatheSignal = fileData.signals.find(s => s.label && s.label.includes('S.EasyBreathe'));

            // Look for EPR-related signals for AirSense machines
            const eprLevelSignal = fileData.signals.find(s => s.label && s.label.includes('S.EPR.Level'));
            const eprEnableSignal = fileData.signals.find(s => s.label && s.label.includes('S.EPR.EPREnable'));
            const cpapPressSignal = fileData.signals.find(s => s.label && s.label.includes('S.C.Press'));

            // Additional Advanced Mode Signals
            const getScaledValues = (signal) => {
                if (!signal || !signal.digitalValues) return [];
                return signal.digitalValues.map((digitalVal, index) => {
                    const physMin = parseFloat(signal.physMin);
                    const physMax = parseFloat(signal.physMax);
                    const digMin = parseInt(signal.digMin);
                    const digMax = parseInt(signal.digMax);
                    if (digMax === digMin) return (signal.physicalValues && signal.physicalValues[index]) ? parseFloat(signal.physicalValues[index]) : 0;
                    const physicalValue = physMin + (digitalVal - digMin) * (physMax - physMin) / (digMax - digMin);
                    return Math.round(physicalValue * 10) / 10;
                });
            };

            const vaMinEPAPValues = getScaledValues(fileData.signals.find(s => s.label && s.label.includes('S.VA.MinEPAP')));
            const vaMaxIPAPValues = getScaledValues(fileData.signals.find(s => s.label && s.label.includes('S.VA.MaxIPAP')));
            const vaPSValues = getScaledValues(fileData.signals.find(s => s.label && s.label.includes('S.VA.PS')));
            const asMinPressValues = getScaledValues(fileData.signals.find(s => s.label && s.label.includes('S.AS.MinPress')));
            const asMaxPressValues = getScaledValues(fileData.signals.find(s => s.label && s.label.includes('S.AS.MaxPress')));

            // Check for AirSense-specific signals (CPAP pressure + EPR)
            const hasEPR = eprLevelSignal && eprEnableSignal;
            const hasCPAPPress = cpapPressSignal;

            console.log('Machine type analysis:', {
                hasEPR: hasEPR,
                hasCPAPPress: hasCPAPPress,
                hasIPAPEPAP: !!(targetIPAPSignal && targetEPAPSignal)
            });

            // Determine if this is an AirSense (CPAP+EPR) or AirCurve (BiPAP) machine
            const isAirSenseMode = hasCPAPPress && hasEPR && !targetIPAPSignal;
            const isAirCurveMode = targetIPAPSignal && targetEPAPSignal;

            console.log('Machine mode detection:', {
                isAirSenseMode: isAirSenseMode,
                isAirCurveMode: isAirCurveMode
            });

            if (!dateSignal) {
                console.log('Date signal not found in STR file');
                return pressureData;
            }

            if (!isAirSenseMode && !isAirCurveMode) {
                console.log('Could not determine machine type - neither AirSense nor AirCurve signals found');
                return pressureData;
            }

            // Extract daily pressure data
            const dates = dateSignal.physicalValues || dateSignal.digitalValues || [];

            // For pressure signals, we need to properly convert digital to physical values
            let ipapValues = [];
            let epapValues = [];

            if (isAirCurveMode) {
                console.log('Processing AirCurve/BiPAP pressure data...');
                // AirCurve machines have separate IPAP and EPAP settings

                // IPAP signals should already be in cmH2O units!
                // The EDF parser is incorrectly applying pressure scaling to signals already in physical units
                if (targetIPAPSignal.physicalValues && targetIPAPSignal.physicalValues.length > 0) {
                    console.log('IPAP Signal is labeled as (cmH2O) - should already be in correct units!');
                    console.log('Signal properties:', {
                        physMin: targetIPAPSignal.physMin,
                        physMax: targetIPAPSignal.physMax,
                        digMin: targetIPAPSignal.digMin,
                        digMax: targetIPAPSignal.digMax,
                        physFactor: targetIPAPSignal.physFactor
                    });

                    // Try using the digital values directly with proper scaling
                    if (targetIPAPSignal.digitalValues && targetIPAPSignal.digitalValues.length > 0) {
                        console.log('Using digital values and calculating proper physical values');
                        ipapValues = targetIPAPSignal.digitalValues.map((digitalVal, index) => {
                            // Calculate proper physical value using signal min/max ranges
                            const physMin = parseFloat(targetIPAPSignal.physMin);
                            const physMax = parseFloat(targetIPAPSignal.physMax);
                            const digMin = parseInt(targetIPAPSignal.digMin);
                            const digMax = parseInt(targetIPAPSignal.digMax);

                            // Linear scaling: physical = physMin + (digital - digMin) * (physMax - physMin) / (digMax - digMin)
                            const physicalValue = physMin + (digitalVal - digMin) * (physMax - physMin) / (digMax - digMin);
                            const rounded = Math.round(physicalValue * 5) / 5; // Round to nearest 0.2

                            if (index < 5) {
                                console.log(`IPAP[${index}]: Digital ${digitalVal} ‚Üí Physical ${physicalValue.toFixed(3)} ‚Üí ${rounded} cmH2O`);
                            }

                            return rounded;
                        });
                    } else {
                        console.log('Falling back to pre-converted values (likely incorrect due to double scaling)');
                        ipapValues = targetIPAPSignal.physicalValues.map(val => {
                            const value = parseFloat(val);
                            return Math.round(value * 5) / 5;
                        });
                    }
                    console.log('Using pre-converted IPAP physical values with scaling correction (√∑50)');
                    console.log('Sample IPAP values (raw):', targetIPAPSignal.physicalValues.slice(0, 5));
                    console.log('Sample IPAP values (corrected):', ipapValues.slice(0, 5));
                } else if (targetIPAPSignal.digitalValues && targetIPAPSignal.physFactor) {
                    // Convert digital to physical using the scaling factor and apply correction
                    ipapValues = targetIPAPSignal.digitalValues.map(digital => {
                        const physicalValue = digital * targetIPAPSignal.physFactor;
                        const correctedValue = physicalValue / 50.0; // Apply scaling correction
                        return Math.round(correctedValue * 20) / 20; // Round to nearest 0.05 for better precision
                    });
                    console.log('Converting IPAP digital to physical with scaling correction');
                    console.log('Factor:', targetIPAPSignal.physFactor, 'with √∑50 correction');
                    console.log('Sample IPAP conversion:', targetIPAPSignal.digitalValues.slice(0, 3), '->', ipapValues.slice(0, 3));
                }

                // Convert EPAP values - physicalValues are already converted and stored as strings
                if (targetEPAPSignal.physicalValues && targetEPAPSignal.physicalValues.length > 0) {
                    // Convert string values to numbers and apply scaling correction
                    // STR file pressure values appear to be scaled by factor of ~50  
                    // Apply same precision approach as IPAP
                    // EPAP signals should already be in cmH2O units!
                    console.log('EPAP Signal is labeled as (cmH2O) - should already be in correct units!');

                    // Try using the digital values directly with proper scaling
                    if (targetEPAPSignal.digitalValues && targetEPAPSignal.digitalValues.length > 0) {
                        console.log('Using digital values and calculating proper physical values for EPAP');
                        epapValues = targetEPAPSignal.digitalValues.map((digitalVal, index) => {
                            // Calculate proper physical value using signal min/max ranges
                            const physMin = parseFloat(targetEPAPSignal.physMin);
                            const physMax = parseFloat(targetEPAPSignal.physMax);
                            const digMin = parseInt(targetEPAPSignal.digMin);
                            const digMax = parseInt(targetEPAPSignal.digMax);

                            // Linear scaling: physical = physMin + (digital - digMin) * (physMax - physMin) / (digMax - digMin)
                            const physicalValue = physMin + (digitalVal - digMin) * (physMax - physMin) / (digMax - digMin);
                            const rounded = Math.round(physicalValue * 5) / 5; // Round to nearest 0.2

                            if (index < 5) {
                                console.log(`EPAP[${index}]: Digital ${digitalVal} ‚Üí Physical ${physicalValue.toFixed(3)} ‚Üí ${rounded} cmH2O`);
                            }

                            return rounded;
                        });
                    } else {
                        console.log('Falling back to pre-converted values (likely incorrect due to double scaling)');
                        epapValues = targetEPAPSignal.physicalValues.map(val => {
                            const value = parseFloat(val);
                            return Math.round(value * 5) / 5;
                        });
                    }
                    console.log('Using pre-converted EPAP physical values with scaling correction');
                    console.log('Sample EPAP values (raw):', targetEPAPSignal.physicalValues.slice(0, 5));
                    console.log('Sample EPAP values (corrected):', epapValues.slice(0, 5));
                } else if (targetEPAPSignal.digitalValues && targetEPAPSignal.physFactor) {
                    // Convert digital to physical using the scaling factor and apply correction
                    epapValues = targetEPAPSignal.digitalValues.map(digital => {
                        const physicalValue = digital * targetEPAPSignal.physFactor;
                        const correctedValue = physicalValue / 50.0; // Apply scaling correction
                        return Math.round(correctedValue * 20) / 20; // Round to nearest 0.05 for better precision
                    });
                    console.log('Converting EPAP digital to physical with scaling correction');
                    console.log('Factor:', targetEPAPSignal.physFactor, 'with √∑50 correction');
                    console.log('Sample EPAP conversion:', targetEPAPSignal.digitalValues.slice(0, 3), '->', epapValues.slice(0, 3));
                }

            } else if (isAirSenseMode) {
                console.log('Processing AirSense/CPAP+EPR pressure data...');
                // AirSense machines use CPAP pressure + EPR (Expiratory Pressure Relief)
                // IPAP = CPAP Pressure, EPAP = CPAP Pressure - EPR Level

                // Get CPAP pressure values
                let cpapPressValues = [];
                if (cpapPressSignal.physicalValues && cpapPressSignal.physicalValues.length > 0) {
                    cpapPressValues = cpapPressSignal.physicalValues.map(val => {
                        const rawValue = parseFloat(val);
                        const correctedValue = rawValue / 50.0; // Apply same scaling correction
                        return Math.round(correctedValue * 10) / 10;
                    });
                    console.log('CPAP pressure values (corrected):', cpapPressValues.slice(0, 5));
                }

                // Get EPR level values
                let eprLevelValues = [];
                if (eprLevelSignal.physicalValues && eprLevelSignal.physicalValues.length > 0) {
                    eprLevelValues = eprLevelSignal.physicalValues.map(val => {
                        const rawValue = parseFloat(val);
                        // EPR is typically 0-5 cmH2O, might not need scaling correction
                        return Math.round(rawValue * 10) / 10;
                    });
                    console.log('EPR level values:', eprLevelValues.slice(0, 5));
                }

                // Check EPR enable status
                let eprEnableValues = [];
                if (eprEnableSignal.physicalValues && eprEnableSignal.physicalValues.length > 0) {
                    eprEnableValues = eprEnableSignal.physicalValues.map(val => parseInt(val));
                } else if (eprEnableSignal.digitalValues && eprEnableSignal.digitalValues.length > 0) {
                    eprEnableValues = eprEnableSignal.digitalValues.map(val => parseInt(val));
                }

                // Calculate IPAP and EPAP for AirSense
                ipapValues = cpapPressValues; // IPAP = CPAP pressure
                epapValues = cpapPressValues.map((cpapPress, index) => {
                    const eprLevel = eprLevelValues[index] || 0;
                    const eprEnabled = eprEnableValues[index] || 0;

                    if (eprEnabled && eprLevel > 0) {
                        // EPAP = CPAP Pressure - EPR Level (when EPR is enabled)
                        const epap = cpapPress - eprLevel;
                        console.log(`EPAP[${index}]: ${cpapPress} - ${eprLevel} = ${epap} (EPR enabled)`);
                        return Math.round(epap * 10) / 10;
                    } else {
                        // EPAP = CPAP Pressure (when EPR is disabled)
                        console.log(`EPAP[${index}]: ${cpapPress} (EPR disabled)`);
                        return cpapPress;
                    }
                });

                console.log('AirSense calculated values:');
                console.log('IPAP (CPAP pressure):', ipapValues.slice(0, 5));
                console.log('EPAP (CPAP - EPR):', epapValues.slice(0, 5));
            }
            const modeValues = modeSignal ? (modeSignal.physicalValues || modeSignal.digitalValues || []) : [];
            const riseTimeValues = riseTimeSignal ? (riseTimeSignal.physicalValues || riseTimeSignal.digitalValues || []) : [];
            const triggerValues = triggerSignal ? (triggerSignal.physicalValues || triggerSignal.digitalValues || []) : [];
            const cycleValues = cycleSignal ? (cycleSignal.physicalValues || cycleSignal.digitalValues || []) : [];
            const easyBreatheValuesRaw = easyBreatheSignal ? (easyBreatheSignal.physicalValues || easyBreatheSignal.digitalValues || []) : [];
            // Normalize EasyBreathe values into 'On'/'Off'
            const easyBreatheValues = easyBreatheValuesRaw.map(v => (parseInt(v) ? 'On' : 'Off'));

            console.log('Data arrays lengths:', {
                dates: dates.length,
                ipap: ipapValues.length,
                epap: epapValues.length,
                mode: modeValues.length,
                riseTime: riseTimeValues.length,
                trigger: triggerValues.length,
                cycle: cycleValues.length,
                easyBreathe: easyBreatheValues.length
            });

            // Debug: Show first few date values to understand the format
            console.log('Sample date values:', dates.slice(0, 5));
            console.log('Sample IPAP values:', ipapValues.slice(0, 5));
            console.log('Sample EPAP values:', epapValues.slice(0, 5));

            for (let i = 0; i < Math.min(dates.length, ipapValues.length, epapValues.length); i++) {
                const dateValue = dates[i];
                const ipapValue = parseFloat(ipapValues[i]);
                const epapValue = parseFloat(epapValues[i]);
                let modeValue = modeValues.length > i ? modeValues[i] : 0;
                let riseTimeValue = riseTimeValues.length > i ? riseTimeValues[i] : undefined;
                const triggerValue = triggerValues.length > i ? triggerValues[i] : undefined;
                const cycleValue = cycleValues.length > i ? cycleValues[i] : undefined;
                const easyBreatheValue = easyBreatheValues.length > i ? easyBreatheValues[i] : undefined;

                // Convert date from various possible formats
                let dateStr = '';
                if (typeof dateValue === 'string' && dateValue.includes('-')) {
                    dateStr = dateValue;
                } else if (typeof dateValue === 'number' || !isNaN(dateValue)) {
                    // Convert from ResMed date format using the file start date as reference
                    const dateNum = parseInt(dateValue);

                    if (i === 0) {
                        console.log(`Processing dates - First value: ${dateNum}, File start: ${fileStartDate}`);
                    }

                    // Use the file start date as the anchor point for the first date entry
                    if (fileStartDate && i === 0) {
                        // Assume the first date entry corresponds to the file start date
                        dateStr = fileStartDate.toISOString().split('T')[0];
                        window.strDateAnchor = {
                            firstDateNum: dateNum,
                            firstDateStr: dateStr
                        };
                        console.log(`Setting date anchor: ${dateNum} -> ${dateStr}`);
                    } else if (window.strDateAnchor) {
                        // Calculate subsequent dates based on the offset from the first date
                        const daysDifference = dateNum - window.strDateAnchor.firstDateNum;
                        const anchorDate = new Date(window.strDateAnchor.firstDateStr);
                        const calculatedDate = new Date(anchorDate.getTime() + daysDifference * 24 * 60 * 60 * 1000);
                        dateStr = calculatedDate.toISOString().split('T')[0];
                    }

                    if (i < 5) {
                        console.log(`Date[${i}]: ${dateNum} -> ${dateStr}`);
                    }
                }

                // Convert mode number to text (using signal count for firmware detection)
                let modeText = convertModeNumberToText(parseInt(modeValue), pressureData.numSignals);

                // Filter invalid Mode -1
                if (parseInt(modeValue) === -1 || modeText.includes('-1')) {
                    continue; // Skip this entry as it's invalid ResMed reporting
                }

                // Normalize additional settings to readable forms
                // If EasyBreathe is On, force rise time to undefined (to be rendered as N/A)
                if (easyBreatheValue === 'On') {
                    riseTimeValue = undefined;
                }
                const riseTimeOut = riseTimeValue !== undefined ? parseFloat(riseTimeValue) : undefined;
                const triggerOut = triggerValue !== undefined ? parseInt(triggerValue) : undefined;
                const cycleOut = cycleValue !== undefined ? parseInt(cycleValue) : undefined;
                const easyBreatheOut = easyBreatheValue !== undefined ? easyBreatheValue : undefined;

                if (dateStr && !isNaN(ipapValue) && !isNaN(epapValue) && ipapValue > 0 && epapValue > 0) {

                    let finalMinIPAP = undefined;
                    let finalMaxIPAP = undefined;
                    let finalMinEPAP = undefined;
                    let finalMaxEPAP = undefined;
                    let finalPS = undefined;

                    // Mode-aware pressure assignment
                    if (modeText.includes('AutoSet')) {
                        finalMinIPAP = asMinPressValues[i];
                        finalMaxIPAP = asMaxPressValues[i];
                    } else if (modeText.includes('VAuto')) {
                        finalMaxIPAP = vaMaxIPAPValues[i];
                        finalPS = vaPSValues[i];
                    } else if (modeText.includes('ASV Auto') || modeText.includes('ASVAuto') || modeText.includes('ASV (9)') || modeText.includes('ASV (10)')) {
                        // ASVAuto uses Min EPAP, Max EPAP, Min PS, Max PS
                        // vaMinEPAPValues = Min EPAP
                        // vaMaxIPAPValues = Max EPAP
                        // vaPSValues = Min PS
                        // d['S.BL.IPAP'] = Max PS (which maps to ipapValues in extracting since IPAP is S.BL.IPAP for ASV)
                        finalMinEPAP = vaMinEPAPValues[i];
                        finalMaxEPAP = vaMaxIPAPValues[i];
                        finalPS = vaPSValues[i]; // This is Min PS
                        // Max PS is stored in IPAP column
                        finalMaxIPAP = ipapValue; // Re-purpose Max IPAP column to show Max PS to save space
                    } else if (modeText.includes('ASV')) {
                        // Fixed ASV uses EPAP, Min PS, Max PS
                        finalMinEPAP = vaMinEPAPValues[i]; // This is fixed EPAP
                        finalPS = vaPSValues[i]; // Min PS
                        finalMaxIPAP = ipapValue; // Max PS
                    }

                    pressureData.dailyData[dateStr] = {
                        ipap: Math.round(ipapValue * 10) / 10,
                        epap: Math.round(epapValue * 10) / 10,
                        minIPAP: finalMinIPAP,
                        maxIPAP: finalMaxIPAP,
                        minEPAP: finalMinEPAP,
                        maxEPAP: finalMaxEPAP,
                        ps: finalPS,
                        mode: modeText,
                        riseTime: riseTimeOut,
                        trigger: triggerOut,
                        cycle: cycleOut,
                        easyBreathe: easyBreatheOut
                    };

                    // Set default mode from first valid entry
                    if (pressureData.defaultMode === 'Unknown') {
                        pressureData.defaultMode = modeText;
                    }
                }
            }

            console.log('Extracted pressure data:', pressureData);
            return pressureData;
        }

        function convertModeNumberToText(modeNum, numSignals = 97) {
            // Mode mapping depends on firmware version (signal count indicates firmware)

            // Pre-AirBreak firmware (<=85 signals) - original limited modes
            const preAirBreakModes = {
                0: 'CPAP',
                1: 'AutoSet',           // Standard APAP
                11: 'AutoSet for Her',  // Default mode for this device
            };

            // Post-AirBreak firmware (>85 signals) - full unlocked mode range
            const postAirBreakModes = {
                0: 'CPAP',
                1: 'CPAP (fixed)',
                2: 'AutoSet',
                3: 'AutoSet for Her',
                4: 'S (BiLevel)',
                5: 'S/T',
                6: 'VAuto',
                7: 'PAC',
                8: 'ASV',
                9: 'ASV Auto',
                10: 'ASV Auto',
                11: 'iVAPS'
            };

            const modeMap = numSignals <= 85 ? preAirBreakModes : postAirBreakModes;
            const modeName = modeMap[modeNum] || `Mode ${modeNum}`;
            return `${modeName} (${modeNum})`;
        }

        function sensitivityLabelFromValue(value) {
            const map = {
                4: 'very high',
                3: 'high',
                2: 'medium',
                1: 'low',
                0: 'very low'
            };
            const n = parseInt(value);
            return (n in map) ? map[n] : (value !== undefined && value !== null ? String(value) : 'N/A');
        }

        function getSessionPressureData(pressureSettings, sessionDate) {
            if (!pressureSettings || !pressureSettings.dailyData) {
                return null;
            }

            // Try to find pressure data for this specific date
            if (pressureSettings.dailyData[sessionDate]) {
                return pressureSettings.dailyData[sessionDate];
            }

            // If direct match fails, check if we have a date conversion issue
            // Try to find a date that could be the same logical date with different year
            const sessionDateParts = sessionDate.split('-');
            const sessionMonth = sessionDateParts[1];
            const sessionDay = sessionDateParts[2];

            // Look for dates with same month/day but different year
            for (const [strDate, data] of Object.entries(pressureSettings.dailyData)) {
                const strDateParts = strDate.split('-');
                if (strDateParts[1] === sessionMonth && strDateParts[2] === sessionDay) {
                    console.log(`Found matching month/day: Using pressure data from ${strDate} for session on ${sessionDate}`);
                    return data;
                }
            }

            // If not found, try nearby dates (within 1 day)
            const sessionDateObj = new Date(sessionDate);
            const nearbyDates = [];

            for (let i = -1; i <= 1; i++) {
                const testDate = new Date(sessionDateObj);
                testDate.setDate(testDate.getDate() + i);
                const testDateStr = testDate.toISOString().split('T')[0];
                if (pressureSettings.dailyData[testDateStr]) {
                    nearbyDates.push({
                        date: testDateStr,
                        data: pressureSettings.dailyData[testDateStr],
                        daysDiff: Math.abs(i)
                    });
                }
            }

            // Return closest match
            if (nearbyDates.length > 0) {
                nearbyDates.sort((a, b) => a.daysDiff - b.daysDiff);
                console.log(`Using pressure data from ${nearbyDates[0].date} for session on ${sessionDate}`);
                return nearbyDates[0].data;
            }

            // If no nearby dates found, return null
            console.log(`No pressure data found for session date: ${sessionDate}. Available dates:`, Object.keys(pressureSettings.dailyData).slice(0, 5));
            return null;
        }

        // Machine identification parsing
        async function parseMachineIdentification(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = function (event) {
                    try {
                        const content = event.target.result;
                        let machineInfo = {};

                        if (file.name.endsWith('.json')) {
                            // Parse JSON format (newer machines like AS11)
                            const jsonData = JSON.parse(content);
                            machineInfo = {
                                type: jsonData.ProductName || 'Unknown',
                                serial: jsonData.SerialNumber || 'Unknown',
                                softwareId: jsonData.SoftwareId || 'Unknown'
                            };
                        } else if (file.name.endsWith('.tgt')) {
                            // Parse TGT format (older machines)
                            const lines = content.split('\n');
                            let productName = 'Unknown';
                            let serialNumber = 'Unknown';
                            let softwareId = 'Unknown';

                            for (const line of lines) {
                                const trimmed = line.trim();
                                if (trimmed.startsWith('#PNA ')) {
                                    productName = trimmed.substring(5).trim();
                                } else if (trimmed.startsWith('#SRN ')) {
                                    serialNumber = trimmed.substring(5).trim();
                                } else if (trimmed.startsWith('#SID ')) {
                                    softwareId = trimmed.substring(5).trim();
                                }
                            }

                            machineInfo = {
                                type: formatMachineType(productName),
                                serial: serialNumber,
                                softwareId: softwareId
                            };
                        }

                        resolve(machineInfo);
                    } catch (error) {
                        reject(new Error(`Failed to parse machine identification: ${error.message}`));
                    }
                };

                reader.onerror = function () {
                    reject(new Error(`Failed to read file ${file.name}`));
                };

                reader.readAsText(file);
            });
        }

        function formatMachineType(productName) {
            if (!productName || productName === 'Unknown') {
                return 'Unknown';
            }

            // Convert underscores to spaces and clean up common ResMed naming
            return productName
                .replace(/_/g, ' ')           // Replace underscores with spaces
                .replace(/([a-z])([A-Z])/g, '$1 $2')  // Add spaces between camelCase
                .replace(/\s+/g, ' ')         // Remove extra spaces
                .trim();
        }

        // CSV Export function for nightly results
        function exportNightlyCSV() {
            if (!window.originalNightlyData || window.originalNightlyData.length === 0) {
                alert('No data available to export. Please analyze some files first.');
                return;
            }

            // Get the data (same as what's displayed in the table)
            const nightlyData = window.originalNightlyData.sort((a, b) => new Date(b.date) - new Date(a.date));

            // Create CSV headers
            const headers = [
                'Date',
                'Start Time',
                'Duration (hours)',
                'Sessions',
                'Machine Type',
                'PAP Mode',
                'Overall GI',
                'Skew',
                'Spike',
                'Flat Top',
                'Top Heavy',
                'Multi Peak',
                'No Pause',
                'Inspir Rate',
                'Multi Breath',
                'Variable Amp',
                'Sleep Disruption',
                'Flow Limitation Score',
                'Regularity Score',
                'Periodicity Score',
                'EAI',
                'IPAP',
                'Min IPAP',
                'Max IPAP',
                'EPAP',
                'Min EPAP',
                'Max EPAP',
                'Pressure Support',
                'EasyBreathe',
                'Rise Time',
                'Trigger',
                'Cycle'
            ];

            // Create CSV rows
            const rows = nightlyData.map(night => [
                night.date,
                formatTimeAMPM(night.startTime),
                night.duration.toFixed(1),
                night.sessions.toString(),
                night.machineType || 'Unknown',
                night.papMode || 'Unknown',
                night.weightedGI.overall.toFixed(2),
                night.weightedGI.skew.toFixed(2),
                night.weightedGI.spike.toFixed(2),
                night.weightedGI.flatTop.toFixed(2),
                night.weightedGI.topHeavy.toFixed(2),
                night.weightedGI.multiPeak.toFixed(2),
                night.weightedGI.noPause.toFixed(2),
                night.weightedGI.inspirRate.toFixed(2),
                night.weightedGI.multiBreath.toFixed(2),
                night.weightedGI.ampVar.toFixed(2),
                night._wobbleAvg ? (night._wobbleAvg.composite || 0).toFixed(1) : 'N/A',
                night._wobbleAvg ? (night._wobbleAvg.flScore || 0).toFixed(1) : 'N/A',
                night._wobbleAvg ? (night._wobbleAvg.regularityScore || 0).toFixed(1) : 'N/A',
                night._wobbleAvg ? (night._wobbleAvg.periodicityIndex || 0).toFixed(1) : 'N/A',
                night._wobbleAvg ? (night._wobbleAvg.eai || 0).toFixed(1) : 'N/A',
                night.ipap !== 'N/A' ? night.ipap.toString() : 'N/A',
                night.minIPAP !== 'N/A' ? night.minIPAP.toString() : 'N/A',
                night.maxIPAP !== 'N/A' ? night.maxIPAP.toString() : 'N/A',
                night.epap !== 'N/A' ? night.epap.toString() : 'N/A',
                night.minEPAP !== 'N/A' ? night.minEPAP.toString() : 'N/A',
                night.maxEPAP !== 'N/A' ? night.maxEPAP.toString() : 'N/A',
                night.pressureSupport !== 'N/A' ? night.pressureSupport.toString() : 'N/A',
                (night.easyBreathe !== 'N/A' ? night.easyBreathe.toString() : 'N/A'),
                (night.riseTime !== 'N/A' ? night.riseTime.toString() : 'N/A'),
                (night.trigger !== 'N/A' ? night.trigger.toString() : 'N/A'),
                (night.cycle !== 'N/A' ? night.cycle.toString() : 'N/A')
            ]);

            // Combine headers and rows
            const csvContent = [headers, ...rows]
                .map(row => row.map(field => `"${field}"`).join(','))
                .join('\n');

            // Create and download the file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');

            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);

                // Generate filename with date range
                const firstDate = nightlyData[nightlyData.length - 1].date;
                const lastDate = nightlyData[0].date;
                const filename = `glasgow_index_${firstDate}_to_${lastDate}.csv`;

                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                // Fallback for older browsers
                window.open('data:text/csv;charset=utf-8,' + encodeURIComponent(csvContent));
            }
        }


        // ============ MEGASCORE: Settings System (localStorage-backed) ============
        const SETTINGS_STORAGE_KEY = 'megascore_settings';

        const DEFAULT_SETTINGS = {
            // Glasgow Index thresholds (from FlowLimits.js)
            gi_skew_lower: 45,
            gi_skew_upper: 55,
            gi_topHeavy_threshold: 40,
            gi_flatTop_threshold: 0.75,
            gi_spike_threshold: 20,
            gi_noPause_threshold: 10,
            gi_inspirRate_threshold: 20,
            gi_ampVar_threshold: 4,
            gi_minPeakBump: 1,

            // Wobble analysis
            wobble_entropy_windowSec: 30,
            wobble_entropy_m: 2,
            wobble_entropy_r: 0.2,
            wobble_fft_enabled: true,
            wobble_flowLim_enabled: true,

            // Session classification
            session_maxGapHours: 6,
            session_napMaxHours: 3,
        };

        let megascoreSettings = {};

        function loadSettings() {
            try {
                const saved = JSON.parse(localStorage.getItem(SETTINGS_STORAGE_KEY) || '{}');
                megascoreSettings = { ...DEFAULT_SETTINGS, ...saved };
            } catch (e) {
                megascoreSettings = { ...DEFAULT_SETTINGS };
            }
        }

        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(megascoreSettings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }

        function openSettings() {
            loadSettings();
            const section = document.getElementById('settingsSection');
            // Populate inputs
            Object.keys(megascoreSettings).forEach(key => {
                const input = document.getElementById('setting_' + key);
                if (input) {
                    if (input.type === 'checkbox') {
                        input.checked = megascoreSettings[key];
                    } else {
                        input.value = megascoreSettings[key];
                    }
                }
            });
            if (section) section.open = true;
        }

        function closeSettings() {
            const section = document.getElementById('settingsSection');
            if (section) section.open = false;
        }

        function applySettings() {
            Object.keys(megascoreSettings).forEach(key => {
                const input = document.getElementById('setting_' + key);
                if (input) {
                    if (input.type === 'checkbox') {
                        megascoreSettings[key] = input.checked;
                    } else if (input.type === 'number') {
                        megascoreSettings[key] = parseFloat(input.value);
                    } else {
                        megascoreSettings[key] = input.value;
                    }
                }
            });
            saveSettings();
            closeSettings();
            // If data is loaded, re-analyze
            if (window.originalNightlyData && window.originalNightlyData.length > 0) {
                alert('Settings saved! To apply changes to already-loaded data, please reload your files.');
            }
        }

        function resetSettings() {
            if (confirm('Reset all settings to defaults?')) {
                megascoreSettings = { ...DEFAULT_SETTINGS };
                saveSettings();
                openSettings(); // refresh the form
            }
        }

        // Load settings on page load
        loadSettings();

        // ============ MEGASCORE: Wobble Analysis Functions ============
        // These are run on each session's flow data to produce additional metrics

        /**
         * Run Wobble analysis on a session's flow data array.
         * Ported exactly from Wobble Analysis Tool (React/Vite).
         * @param {Array} dataArray - The flow data array [{x, y}, ...]
         * @param {number} sampleRateHz - Sample rate in Hz (usually 25)
         * @returns {Object} Wobble metrics
         */
        function runWobbleAnalysis(dataArray, sampleRateHz) {
            if (!dataArray || dataArray.length === 0) {
                return { flScore: 0, periodicityIndex: 0, regularityScore: 0, eai: 0, composite: 0, durationMinutes: 0 };
            }

            const flowData = dataArray.map(d => parseFloat(d.y));
            const durationMinutes = (flowData.length / sampleRateHz) / 60;

            // 1. Flow Limitation
            const breaths = [];
            let inInspiration = false;
            let inspirationStart = 0;
            let currentBreath = null;

            for (let i = 1; i < flowData.length; i++) {
                if (flowData[i] > 0 && flowData[i - 1] <= 0) {
                    inspirationStart = i;
                    inInspiration = true;
                    currentBreath = {
                        start: i,
                        end: i,
                        inspStart: inspirationStart,
                        inspEnd: i,
                        startTime: i / sampleRateHz
                    };
                    breaths.push(currentBreath);
                } else if (flowData[i] <= 0 && flowData[i - 1] > 0) {
                    if (inInspiration && currentBreath) {
                        currentBreath.inspEnd = i;
                        currentBreath.end = i;
                        currentBreath.endTime = i / sampleRateHz;
                    }
                    inInspiration = false;
                }
            }

            const flScores = [];
            for (const breath of breaths) {
                const inspFlow = flowData.slice(breath.inspStart, breath.inspEnd);
                if (inspFlow.length < 10) continue;

                const maxFlow = Math.max(...inspFlow);
                if (maxFlow < 0.1) continue;

                const normalizedFlow = inspFlow.map(f => f / maxFlow);

                const topHalfStart = normalizedFlow.findIndex(f => f > 0.5);
                const topHalfEnd = normalizedFlow.length - [...normalizedFlow].reverse().findIndex(f => f > 0.5);

                if (topHalfStart >= 0 && topHalfEnd > topHalfStart) {
                    const topHalf = normalizedFlow.slice(topHalfStart, topHalfEnd);
                    const topHalfMean = topHalf.reduce((a, b) => a + b) / topHalf.length;
                    const topHalfVariance = topHalf.reduce((sum, val) => {
                        const diff = val - topHalfMean;
                        return sum + diff * diff;
                    }, 0) / topHalf.length;

                    const flatness = Math.max(0, Math.min(100, (0.05 - topHalfVariance) / 0.05 * 100));
                    flScores.push(flatness);
                }
            }
            const flScore = flScores.length > 0 ? flScores.reduce((a, b) => a + b) / flScores.length : 0;

            // 2. Arousal Estimation (EAI)
            let eai = 0;
            if (breaths.length >= 10 && durationMinutes > 0) {
                const breathMetrics = [];
                for (let i = 1; i < breaths.length; i++) {
                    const breath = breaths[i];
                    const prevBreath = breaths[i - 1];

                    const breathDuration = breath.startTime - prevBreath.startTime;
                    if (breathDuration <= 0 || breathDuration > 20) continue;

                    const respiratoryRate = 60 / breathDuration;
                    const inspFlow = flowData.slice(breath.inspStart, breath.inspEnd);
                    const tidalVolume = inspFlow.reduce((sum, f) => sum + Math.abs(f), 0) / sampleRateHz;

                    breathMetrics.push({
                        time: breath.startTime, rate: respiratoryRate, volume: tidalVolume, breathIndex: i
                    });
                }

                if (breathMetrics.length >= 10) {
                    const baselineWindow = 120;
                    const arousals = [];

                    for (let i = 0; i < breathMetrics.length; i++) {
                        const currentMetric = breathMetrics[i];
                        const baselineStart = Math.max(0, i - Math.floor(baselineWindow / (60 / currentMetric.rate)));
                        const baselineMetrics = breathMetrics.slice(baselineStart, i);

                        if (baselineMetrics.length < 5) continue;

                        const baselineRate = baselineMetrics.reduce((sum, m) => sum + m.rate, 0) / baselineMetrics.length;
                        const baselineVolume = baselineMetrics.reduce((sum, m) => sum + m.volume, 0) / baselineMetrics.length;

                        const rateIncrease = (currentMetric.rate - baselineRate) / baselineRate;
                        const volumeIncrease = (currentMetric.volume - baselineVolume) / baselineVolume;

                        if (rateIncrease > 0.20 || volumeIncrease > 0.30) {
                            const recentArousal = arousals.length > 0 &&
                                (currentMetric.time - arousals[arousals.length - 1].time) < 15;

                            if (!recentArousal) {
                                arousals.push({ time: currentMetric.time });
                            }
                        }
                    }
                    eai = durationMinutes > 0 ? arousals.length / (durationMinutes / 60) : 0;
                }
            }

            // 3. Minute Ventilation & Entropy & FFT
            let regularityScore = 0;
            let periodicityIndex = 0;

            const windowSize = Math.floor(60 * sampleRateHz);
            const stepSize = Math.floor(5 * sampleRateHz);
            const minuteVent = [];

            for (let i = 0; i < flowData.length - windowSize; i += stepSize) {
                const window = flowData.slice(i, i + windowSize);
                let tidalVolume = 0;
                let breathCount = 0;
                let inInhalation = false;

                for (let j = 1; j < window.length; j++) {
                    if (window[j] > 0 && window[j - 1] <= 0) { breathCount++; inInhalation = true; }
                    if (inInhalation && window[j] > 0) tidalVolume += Math.abs(window[j]) / sampleRateHz;
                    if (window[j] <= 0) inInhalation = false;
                }
                minuteVent.push((tidalVolume * breathCount) / 60);
            }

            if (minuteVent.length > 0) {
                const mvMean = minuteVent.reduce((a, b) => a + b) / minuteVent.length;
                const detrended = minuteVent.map(v => v - mvMean);

                // Sample Entropy on Minute Ventilation
                const variance = minuteVent.reduce((sum, val) => sum + Math.pow(val - mvMean, 2), 0) / minuteVent.length;
                const r = 0.2 * Math.sqrt(variance);

                const countMatches = (m) => {
                    let count = 0;
                    const N = minuteVent.length;
                    for (let i = 0; i < N - m; i++) {
                        for (let j = i + 1; j < N - m; j++) {
                            let match = true;
                            for (let k = 0; k < m; k++) {
                                if (Math.abs(minuteVent[i + k] - minuteVent[j + k]) > r) {
                                    match = false; break;
                                }
                            }
                            if (match) count++;
                        }
                    }
                    return count;
                };

                const B = countMatches(2);
                const A = countMatches(3);
                const sampleEntropy = (B === 0 || A === 0) ? 0 : -Math.log(A / B);
                regularityScore = Math.max(0, Math.min(100, 100 - (sampleEntropy / 2.5) * 100));

                // FFT on Detrended Minute Ventilation
                const fft = (x) => {
                    const N = x.length;
                    if (N <= 1) return x;

                    if (N % 2 !== 0) {
                        const pow = Math.pow(2, Math.ceil(Math.log2(N)));
                        const padded = [...x, ...new Array(pow - N).fill({ re: 0, im: 0 })];
                        return fft(padded);
                    }

                    const even = fft(x.filter((_, i) => i % 2 === 0));
                    const odd = fft(x.filter((_, i) => i % 2 === 1));

                    const result = new Array(N);
                    for (let k = 0; k < N / 2; k++) {
                        const angle = -2 * Math.PI * k / N;
                        const t = {
                            re: Math.cos(angle) * odd[k].re - Math.sin(angle) * odd[k].im,
                            im: Math.cos(angle) * odd[k].im + Math.sin(angle) * odd[k].re
                        };
                        result[k] = { re: even[k].re + t.re, im: even[k].im + t.im };
                        result[k + N / 2] = { re: even[k].re - t.re, im: even[k].im - t.im };
                    }
                    return result;
                };

                try {
                    const n = Math.pow(2, Math.ceil(Math.log2(detrended.length)));
                    const padded = [...detrended, ...new Array(n - detrended.length).fill(0)];
                    const complex = padded.map(v => ({ re: v, im: 0 }));
                    const spectrum = fft(complex);
                    const power = spectrum.slice(0, n / 2).map(c => Math.sqrt(c.re * c.re + c.im * c.im));

                    const dt = 5; // stepSize in seconds
                    const freqs = power.map((_, i) => i / (n * dt));
                    const totalPower = power.reduce((a, b) => a + b, 0);
                    const pbPower = power.filter((p, i) => freqs[i] >= 0.01 && freqs[i] <= 0.03).reduce((a, b) => a + b, 0);
                    periodicityIndex = Math.min(100, (pbPower / totalPower) * 200);
                } catch (e) {
                    console.error("FFT computation failed", e);
                }
            }

            const composite = (((flScore + periodicityIndex + regularityScore) / 3 + eai) / 2);

            return {
                flScore,
                periodicityIndex,
                regularityScore,
                eai,
                composite,
                durationMinutes
            };
        }

    </script>

    <!-- Analysis Settings (always visible, collapsible) -->
    <div class="container" style="margin-top: 16px;">
        <details id="settingsSection" ontoggle="if(this.open) openSettings();">
            <summary style="cursor:pointer; font-weight:600;">‚öôÔ∏è Analysis Settings</summary>
            <div style="margin-top:15px;">

                <p style="color:#666; font-size:13px; margin-bottom:20px;">These parameters control the analysis
                    algorithms.
                    Changes are saved to localStorage and persist across sessions.</p>

                <h3 style="color:#007bff; border-bottom:1px solid #e0e0e0; padding-bottom:8px;">Glasgow Index Thresholds
                </h3>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:20px;">
                    <label style="font-size:13px;">Skew Lower % <input type="number" id="setting_gi_skew_lower" min="0"
                            max="50" step="1" style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Skew Upper % <input type="number" id="setting_gi_skew_upper" min="50"
                            max="100" step="1" style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Top Heavy % <input type="number" id="setting_gi_topHeavy_threshold"
                            min="0" max="100" step="1" style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Flat Top Var <input type="number" id="setting_gi_flatTop_threshold"
                            min="0" max="10" step="0.05" style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Spike % <input type="number" id="setting_gi_spike_threshold" min="0"
                            max="50" step="1" style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">No Pause (samples) <input type="number"
                            id="setting_gi_noPause_threshold" min="0" max="50" step="1"
                            style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Inspir Rate (/min) <input type="number"
                            id="setting_gi_inspirRate_threshold" min="0" max="60" step="1"
                            style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Amp Variance <input type="number" id="setting_gi_ampVar_threshold"
                            min="0" max="20" step="0.5" style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Min Peak Bump <input type="number" id="setting_gi_minPeakBump"
                            min="0" max="10" step="0.1" style="width:60px; margin-left:5px;"></label>
                </div>

                <h3 style="color:#007bff; border-bottom:1px solid #e0e0e0; padding-bottom:8px;">Wobble Analysis</h3>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:20px;">
                    <label style="font-size:13px;">Entropy Window (sec) <input type="number"
                            id="setting_wobble_entropy_windowSec" min="5" max="300" step="5"
                            style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Entropy Template (m) <input type="number"
                            id="setting_wobble_entropy_m" min="1" max="5" step="1"
                            style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Entropy Tolerance (r) <input type="number"
                            id="setting_wobble_entropy_r" min="0.01" max="1" step="0.01"
                            style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;"><input type="checkbox" id="setting_wobble_fft_enabled"
                            style="margin-right:5px;">Enable FFT Analysis</label>
                    <label style="font-size:13px;"><input type="checkbox" id="setting_wobble_flowLim_enabled"
                            style="margin-right:5px;">Enable Flow Limitation</label>
                </div>

                <h3 style="color:#007bff; border-bottom:1px solid #e0e0e0; padding-bottom:8px;">Session Classification
                </h3>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:20px;">
                    <label style="font-size:13px;">Max Gap Hours <input type="number" id="setting_session_maxGapHours"
                            min="1" max="12" step="0.5" style="width:60px; margin-left:5px;"></label>
                    <label style="font-size:13px;">Nap Max Hours <input type="number" id="setting_session_napMaxHours"
                            min="0.5" max="6" step="0.5" style="width:60px; margin-left:5px;"></label>
                </div>

                <div
                    style="display:flex; gap:10px; justify-content:flex-end; margin-top:20px; border-top:1px solid #e0e0e0; padding-top:15px;">
                    <button onclick="resetSettings()"
                        style="padding:8px 16px; background:#dc3545; color:white; border:none; border-radius:4px; cursor:pointer;">Reset
                        to Defaults</button>
                    <button onclick="applySettings()"
                        style="padding:8px 16px; background:#007bff; color:white; border:none; border-radius:4px; cursor:pointer;">Save
                        Settings</button>
                </div>

            </div>
        </details>
    </div>

</body>

</html>